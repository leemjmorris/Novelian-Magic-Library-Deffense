name: Issue Workflow

on:
  issues:
    types: [opened, assigned, labeled, reopened]

permissions:
  issues: write

jobs:
  handle-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts/user-mapping.json
          sparse-checkout-cone-mode: false

      - name: Handle Issue Event
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        with:
          script: |
            const fs = require('fs');
            const https = require('https');

            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title;
            const issueBody = context.payload.issue.body || '';
            const issueUrl = context.payload.issue.html_url;
            const action = context.payload.action;
            const labels = context.payload.issue.labels.map(l => l.name);
            const assignees = context.payload.issue.assignees;
            const assignee = assignees.length > 0 ? assignees[0].login : null;

            // Load user mapping from JSON file
            const userMappingData = JSON.parse(fs.readFileSync('.github/scripts/user-mapping.json', 'utf8'));
            const userMapping = {};
            for (const [username, data] of Object.entries(userMappingData)) {
              userMapping[username] = data.slackId;
            }
            
            function removeMarkdown(text) {
              if (!text) return '';
              let result = text;
              result = result.replace(/```[\s\S]*?```/g, '');
              result = result.replace(/^#{1,6}\s+/gm, '');
              result = result.replace(/^\s*[-*+]\s*\[[ xX]\]\s*/gm, '');
              result = result.replace(/\*\*\*(.+?)\*\*\*/g, '$1');
              result = result.replace(/\*\*(.+?)\*\*\*/g, '$1');
              result = result.replace(/\*\*(.+?)\*\*/g, '$1');
              result = result.replace(/\*(.+?)\*/g, '$1');
              result = result.replace(/___(.+?)___/g, '$1');
              result = result.replace(/__(.+?)__/g, '$1');
              result = result.replace(/_(.+?)_/g, '$1');
              result = result.replace(/~~(.+?)~~/g, '$1');
              result = result.replace(/`(.+?)`/g, '$1');
              result = result.replace(/^\s*[-*+]\s+/gm, '');
              result = result.replace(/^\s*\d+\.\s+/gm, '');
              result = result.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
              result = result.replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1');
              result = result.replace(/>\s+/gm, '');
              result = result.replace(/`([^`]+)`/g, '$1');
              result = result.replace(/^\s*[-=]{3,}\s*$/gm, '');
              result = result.replace(/\|/g, '');
              result = result.replace(/\n{3,}/g, '\n\n');
              return result.trim();
            }
            
            function sanitizeForSlack(text) {
              if (!text) return '';
              return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n{3,}/g, '\n\n')
                .trim()
                .substring(0, 2000);
            }
            
            function callGeminiAPI(prompt) {
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  contents: [{
                    parts: [{ text: prompt }]
                  }]
                });
                
                const options = {
                  hostname: 'generativelanguage.googleapis.com',
                  path: '/v1beta/models/gemini-2.5-flash:generateContent?key=' + process.env.GEMINI_API_KEY,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      try {
                        const response = JSON.parse(body);
                        const text = response.candidates?.[0]?.content?.parts?.[0]?.text || null;
                        resolve(text);
                      } catch (error) {
                        console.log('Gemini parse error:', error.message);
                        resolve(null);
                      }
                    } else {
                      console.log('Gemini API error:', res.statusCode);
                      resolve(null);
                    }
                  });
                });
                
                req.on('error', (err) => {
                  console.log('Gemini request error:', err.message);
                  resolve(null);
                });
                req.write(data);
                req.end();
              });
            }
            
            function sendToSlack(message) {
              return new Promise((resolve, reject) => {
                const data = JSON.stringify(message);
                const url = new URL(process.env.SLACK_WEBHOOK_URL);
                
                const options = {
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json; charset=utf-8',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200 && body === 'ok') {
                      resolve(body);
                    } else {
                      reject(new Error('Slack: ' + res.statusCode + ' - ' + body));
                    }
                  });
                });
                
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            function addToNotion(properties) {
              return new Promise((resolve) => {
                if (!process.env.NOTION_API_TOKEN) {
                  resolve('skipped');
                  return;
                }
                
                const data = JSON.stringify({
                  parent: { database_id: process.env.NOTION_DATABASE_ID },
                  properties: properties
                });
                
                const options = {
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + process.env.NOTION_API_TOKEN,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => resolve(body));
                });
                
                req.on('error', () => resolve('error'));
                req.write(data);
                req.end();
              });
            }
            
            try {
              if (action === 'opened') {
                console.log('Processing Issue #' + issueNumber);
                
                let summary = null;
                if (issueBody && issueBody.trim().length > 0) {
                  console.log('ğŸ“¨ Calling Gemini API...');
                  const prompt = 'ì•„ë˜ GitHub Issueë¥¼ ì½ê³  í•µì‹¬ ë‚´ìš©ë§Œ ì¶”ë ¤ì„œ 3-5ë¬¸ì¥ìœ¼ë¡œ ê°„ê²°í•˜ê²Œ ìš”ì•½í•´ì£¼ì„¸ìš”.\n\nğŸš¨ ì ˆëŒ€ ì§€ì¼œì•¼ í•  ê·œì¹™:\n1. ìˆœìˆ˜í•œ í‰ë¬¸(plain text)ìœ¼ë¡œë§Œ ì‘ì„±í•˜ì„¸ìš”.\n2. ë§ˆí¬ë‹¤ìš´ ë¬¸ë²•ì„ ì ˆëŒ€ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”: #, ##, -, *, **, __, `, [], (), ~~ ë“± ëª¨ë‘ ê¸ˆì§€\n3. ì²´í¬ë°•ìŠ¤ í‘œì‹œë¥¼ ì ˆëŒ€ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”: [ ], [x] ê¸ˆì§€\n4. ë¶ˆë › í¬ì¸íŠ¸, ë²ˆí˜¸ ë§¤ê¸°ê¸°, ì„¹ì…˜ í—¤ë”ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.\n5. í•˜ë‚˜ì˜ ìì—°ìŠ¤ëŸ¬ìš´ ë¬¸ë‹¨ìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”.\n6. "ì´ ì´ìŠˆëŠ”..." ë˜ëŠ” "ì´ ì‘ì—…ì€..."ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”.\n7. ì›ë³¸ í…ìŠ¤íŠ¸ë¥¼ ê·¸ëŒ€ë¡œ ë³µì‚¬í•˜ì§€ ë§ê³ , ë‹¹ì‹ ì˜ ì–¸ì–´ë¡œ ë‹¤ì‹œ ì‘ì„±í•˜ì„¸ìš”.\n\nâœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ:\nì´ ì´ìŠˆëŠ” ìŠ¤í…Œì´ì§€ íƒ€ì´ë¨¸ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ëŠ” ì‘ì—…ì…ë‹ˆë‹¤. ë‚¨ì€ ì‹œê°„ì„ ê³„ì‚°í•˜ê³  ì½˜ì†”ì— ì¶œë ¥í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ë©°, íƒ€ì´ë¨¸ê°€ 0ì´ ë˜ë©´ ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤. íƒ€ì´ë¨¸ëŠ” UIì—ë„ í‘œì‹œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.\n\nâŒ ì˜ëª»ëœ ì˜ˆì‹œ (ë§ˆí¬ë‹¤ìš´ ì‚¬ìš©):\nStage Timer Sys êµ¬í˜„ - [ ] ë‚¨ì€ ì‹œê°„ ê³„ì‚°\n\nì´ìŠˆ ì œëª©: ' + issueTitle + '\n\nì´ìŠˆ ë‚´ìš©:\n' + issueBody.substring(0, 3000) + '\n\nìœ„ ê·œì¹™ì„ ë°˜ë“œì‹œ ì§€ì¼œì„œ ìˆœìˆ˜í•œ í‰ë¬¸ìœ¼ë¡œë§Œ ìš”ì•½í•´ì£¼ì„¸ìš”. ë§ˆí¬ë‹¤ìš´, ì²´í¬ë°•ìŠ¤, ê¸°í˜¸ë¥¼ ì ˆëŒ€ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.';

                  try {
                    const rawSummary = await callGeminiAPI(prompt);

                    if (rawSummary && rawSummary.trim().length > 0) {
                      console.log('ğŸ¤– Gemini raw response:', rawSummary.substring(0, 200));
                      summary = removeMarkdown(rawSummary);

                      // Validate summary quality
                      if (summary.trim().length < 10) {
                        console.log('âš ï¸ Summary too short after cleaning, using fallback');
                        summary = null;
                      } else if (summary.includes('```') || summary.includes('##')) {
                        console.log('âš ï¸ Summary still contains markdown, cleaning again');
                        summary = removeMarkdown(summary);
                      }

                      console.log('ğŸ¤– After markdown removal:', summary.substring(0, 200));
                    } else {
                      console.log('âš ï¸ Gemini returned empty response');
                      summary = null;
                    }
                  } catch (error) {
                    console.log('âš ï¸ Gemini API call failed:', error.message);
                    summary = null;
                  }

                  // Fallback if summary is invalid
                  if (!summary) {
                    console.log('ğŸ“ Using fallback summary from issue body');
                    const lines = issueBody.split('\n').filter(line => {
                      const trimmed = line.trim();
                      return trimmed.length > 0 &&
                             !trimmed.startsWith('#') &&
                             !trimmed.startsWith('-') &&
                             !trimmed.startsWith('*') &&
                             !trimmed.match(/^\[[ xX]\]/);
                    });
                    summary = lines.slice(0, 3).join(' ').substring(0, 500);
                  }
                }
                
                const safeTitle = sanitizeForSlack(issueTitle);
                const safeSummary = summary ? sanitizeForSlack(summary) : null;
                const slackUserId = assignee ? userMapping[assignee] : null;
                const assigneeName = slackUserId ? '<@' + slackUserId + '>' : (assignee || 'ë¯¸ì§€ì •');
                const labelsText = labels.length > 0 ? labels.join(', ') : 'ì—†ìŒ';
                
                const blocks = [
                  {
                    type: 'header',
                    text: {
                      type: 'plain_text',
                      text: 'ğŸ†• New Issue #' + issueNumber,
                      emoji: true
                    }
                  },
                  {
                    type: 'section',
                    fields: [
                      {
                        type: 'mrkdwn',
                        text: '*ì œëª©*\n' + safeTitle
                      },
                      {
                        type: 'mrkdwn',
                        text: '*ë‹´ë‹¹ì*\n' + assigneeName
                      }
                    ]
                  }
                ];
                
                if (labels.length > 0) {
                  blocks.push({
                    type: 'section',
                    fields: [
                      {
                        type: 'mrkdwn',
                        text: '*Labels*\n' + labelsText
                      }
                    ]
                  });
                }
                
                if (safeSummary && safeSummary.length > 0) {
                  blocks.push({
                    type: 'divider'
                  });
                  blocks.push({
                    type: 'section',
                    text: {
                      type: 'mrkdwn',
                      text: '*ğŸ¤– AI ìš”ì•½*\n' + safeSummary
                    }
                  });
                }
                
                blocks.push({
                  type: 'divider'
                });
                blocks.push({
                  type: 'actions',
                  elements: [
                    {
                      type: 'button',
                      text: {
                        type: 'plain_text',
                        text: 'View Issue',
                        emoji: true
                      },
                      url: issueUrl,
                      style: 'primary'
                    }
                  ]
                });
                
                const slackMessage = {
                  text: 'New Issue #' + issueNumber,
                  blocks: blocks
                };
                
                console.log('ğŸ“¨ Sending to Slack');
                await sendToSlack(slackMessage);
                console.log('âœ… Slack ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ');
                
                await addToNotion({
                  'Name': { title: [{ text: { content: issueTitle } }] },
                  'Issue Number': { number: issueNumber },
                  'Status': { select: { name: 'Open' } },
                  'URL': { url: issueUrl },
                  'Assignee': assignee ? { rich_text: [{ text: { content: assignee } }] } : { rich_text: [] }
                });
              }
              
              const hasImportantLabel = labels.some(label =>
                ['urgent', 'critical', 'bug', 'hotfix'].includes(label.toLowerCase())
              );

              if (hasImportantLabel && assignee) {
                const slackUserId = userMapping[assignee];
                const mention = slackUserId ? '<@' + slackUserId + '>' : assignee;

                await sendToSlack({
                  text: 'Important Issue ' + issueNumber,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'ğŸš¨ Important Issue Alert',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: mention + ' ì¤‘ìš”í•œ Issueê°€ í• ë‹¹ë˜ì—ˆìŠµë‹ˆë‹¤.'
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: '*Issue #' + issueNumber + '*\n' + sanitizeForSlack(issueTitle)
                        },
                        {
                          type: 'mrkdwn',
                          text: '*Labels*\n' + labels.join(', ')
                        }
                      ]
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'View Issue'
                          },
                          url: issueUrl,
                          style: 'danger'
                        }
                      ]
                    }
                  ]
                });
              }

              if (action === 'reopened') {
                const slackUserId = assignee ? userMapping[assignee] : null;
                const mention = slackUserId ? '<@' + slackUserId + '>' : (assignee || 'ë¯¸ì§€ì •');

                await sendToSlack({
                  text: 'Issue Reopened #' + issueNumber,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'ğŸ”„ Issue ì¬ì˜¤í”ˆ',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: '*Issue #' + issueNumber + '*\n' + sanitizeForSlack(issueTitle)
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ë‹´ë‹¹ì*\n' + mention
                        }
                      ]
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: 'âš ï¸ ì™„ë£Œëœ Issueê°€ ì¬ì˜¤í”ˆë˜ì—ˆìŠµë‹ˆë‹¤. ì¶”ê°€ ì‘ì—…ì´ í•„ìš”í•©ë‹ˆë‹¤.'
                      }
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'View Issue'
                          },
                          url: issueUrl,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                });
              }

              console.log('âœ… Workflow completed');
              
            } catch (error) {
              console.error('âŒ Workflow failed:', error.message);
              throw error;
            }
