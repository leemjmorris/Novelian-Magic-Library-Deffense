name: Issue Workflow

on:
  issues:
    types: [opened, assigned, reopened]

permissions:
  contents: write
  issues: write

jobs:
  handle-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Handle Issue Event
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        with:
          script: |
            const https = require('https');
            const { execSync } = require('child_process');
            
            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title;
            const issueBody = context.payload.issue.body || '';
            const issueUrl = context.payload.issue.html_url;
            const action = context.payload.action;
            const labels = context.payload.issue.labels.map(l => l.name);
            const assignees = context.payload.issue.assignees;
            const assignee = assignees.length > 0 ? assignees[0].login : null;
            
            const userMapping = {
              'leemjmorris': 'U09R6F3CBHN',
              'jaemoon23': 'U09QR380TLH',
              'LeeChaeBin002': 'U09QFND0J20',
              'Kdwio': 'U09LZ9Q6F3J',
              'bunggoo0105': 'U09RL7QCYV7',
              'JangYeJin1207': 'U09QAEF5FEJ'
            };
            
            function sanitizeForSlack(text) {
              if (!text) return '';
              return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/`/g, '')
                .replace(/\*/g, '')
                .replace(/_/g, '')
                .replace(/~/g, '')
                .replace(/\n{3,}/g, '\n\n')
                .trim()
                .substring(0, 500);
            }
            
            function callGeminiAPI(prompt) {
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  contents: [{
                    parts: [{ text: prompt }]
                  }]
                });
                
                const options = {
                  hostname: 'generativelanguage.googleapis.com',
                  path: '/v1beta/models/gemini-pro:generateContent?key=' + process.env.GEMINI_API_KEY,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': data.length
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      try {
                        const response = JSON.parse(body);
                        const text = response.candidates?.[0]?.content?.parts?.[0]?.text || null;
                        resolve(text);
                      } catch (error) {
                        resolve(null);
                      }
                    } else {
                      resolve(null);
                    }
                  });
                });
                
                req.on('error', () => resolve(null));
                req.write(data);
                req.end();
              });
            }
            
            function sendToSlack(message) {
              return new Promise((resolve, reject) => {
                const data = JSON.stringify(message);
                const url = new URL(process.env.SLACK_WEBHOOK_URL);
                
                const options = {
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': data.length
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200 && body === 'ok') {
                      resolve(body);
                    } else {
                      reject(new Error(`Slack: ${res.statusCode} - ${body}`));
                    }
                  });
                });
                
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            function addToNotion(properties) {
              return new Promise((resolve) => {
                if (!process.env.NOTION_API_TOKEN) {
                  resolve('skipped');
                  return;
                }
                
                const data = JSON.stringify({
                  parent: { database_id: process.env.NOTION_DATABASE_ID },
                  properties: properties
                });
                
                const options = {
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + process.env.NOTION_API_TOKEN,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28',
                    'Content-Length': data.length
                  }
                };
                
                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => resolve(body));
                });
                
                req.on('error', () => resolve('error'));
                req.write(data);
                req.end();
              });
            }
            
            try {
              if (action === 'opened') {
                console.log(`Processing Issue #${issueNumber}`);
                
                let summary = null;
                if (issueBody && issueBody.trim().length > 0) {
                  const prompt = `Îã§Ïùå GitHub IssueÎ•º 2-3Ï§ÑÎ°ú Í∞ÑÎã®Ìûà ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî. ÌäπÏàòÎ¨∏ÏûêÎÇò ÎßàÌÅ¨Îã§Ïö¥ Ìè¨Îß∑ÌåÖ ÏóÜÏù¥ ÌèâÎ≤îÌïú ÌÖçÏä§Ìä∏Î°úÎßå ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî:\n\nÏ†úÎ™©: ${issueTitle}\n\nÎÇ¥Ïö©: ${issueBody.substring(0, 2000)}`;
                  summary = await callGeminiAPI(prompt);
                  
                  if (summary) {
                    console.log('ü§ñ Gemini raw response:', summary);
                    console.log('ü§ñ Gemini response length:', summary.length);
                  }
                }
                
                const safeTitle = sanitizeForSlack(issueTitle);
                const safeSummary = summary ? sanitizeForSlack(summary) : null;
                const assigneeName = assignee || 'ÎØ∏ÏßÄÏ†ï';
                const labelsText = labels.length > 0 ? labels.join(', ') : 'ÏóÜÏùå';
                
                console.log('üìù Safe title:', safeTitle);
                console.log('üìù Safe summary:', safeSummary);
                
                const blocks = [
                  {
                    type: 'header',
                    text: {
                      type: 'plain_text',
                      text: `New Issue #${issueNumber}`,
                      emoji: true
                    }
                  },
                  {
                    type: 'section',
                    fields: [
                      {
                        type: 'mrkdwn',
                        text: `*Ï†úÎ™©*\n${safeTitle}`
                      },
                      {
                        type: 'mrkdwn',
                        text: `*Îã¥ÎãπÏûê*\n${assigneeName}`
                      }
                    ]
                  }
                ];
                
                if (labels.length > 0) {
                  blocks.push({
                    type: 'section',
                    fields: [
                      {
                        type: 'mrkdwn',
                        text: `*Labels*\n${labelsText}`
                      }
                    ]
                  });
                }
                
                if (safeSummary) {
                  blocks.push({
                    type: 'divider'
                  });
                  blocks.push({
                    type: 'section',
                    text: {
                      type: 'mrkdwn',
                      text: `*AI ÏöîÏïΩ*\n${safeSummary}`
                    }
                  });
                }
                
                blocks.push({
                  type: 'divider'
                });
                blocks.push({
                  type: 'actions',
                  elements: [
                    {
                      type: 'button',
                      text: {
                        type: 'plain_text',
                        text: 'View Issue',
                        emoji: true
                      },
                      url: issueUrl,
                      style: 'primary'
                    }
                  ]
                });
                
                const slackMessage = {
                  text: `New Issue #${issueNumber}: ${issueTitle}`,
                  blocks: blocks
                };
                
                console.log('üì® Sending Slack message...');
                await sendToSlack(slackMessage);
                console.log('‚úÖ Slack notification sent');
                
                await addToNotion({
                  'Name': { title: [{ text: { content: issueTitle } }] },
                  'Issue Number': { number: issueNumber },
                  'Status': { select: { name: 'Open' } },
                  'URL': { url: issueUrl },
                  'Assignee': assignee ? { rich_text: [{ text: { content: assignee } }] } : { rich_text: [] }
                });
                
                if (assignee) {
                  try {
                    const branchName = `issue-${issueNumber}`;
                    execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
                    execSync(`git push origin ${branchName}`, { stdio: 'inherit' });
                    
                    const slackUserId = userMapping[assignee];
                    const mention = slackUserId ? `<@${slackUserId}>` : assignee;
                    
                    await sendToSlack({
                      text: `Branch created: ${branchName}`,
                      blocks: [
                        {
                          type: 'section',
                          text: {
                            type: 'mrkdwn',
                            text: `Branch ÏÉùÏÑ± ÏôÑÎ£å\n${branchName}\nÎã¥ÎãπÏûê: ${mention}`
                          }
                        },
                        {
                          type: 'actions',
                          elements: [
                            {
                              type: 'button',
                              text: {
                                type: 'plain_text',
                                text: 'View Issue'
                              },
                              url: issueUrl
                            }
                          ]
                        }
                      ]
                    });
                  } catch (error) {
                    console.log('Branch creation skipped:', error.message);
                  }
                }
              }
              
              if (action === 'assigned' && assignee) {
                const branchName = `issue-${issueNumber}`;
                
                try {
                  execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
                  execSync(`git push origin ${branchName}`, { stdio: 'inherit' });
                  
                  const slackUserId = userMapping[assignee];
                  const mention = slackUserId ? `<@${slackUserId}>` : assignee;
                  
                  await sendToSlack({
                    text: `Issue #${issueNumber} assigned and branch created`,
                    blocks: [
                      {
                        type: 'header',
                        text: {
                          type: 'plain_text',
                          text: 'Branch Created',
                          emoji: true
                        }
                      },
                      {
                        type: 'section',
                        fields: [
                          {
                            type: 'mrkdwn',
                            text: `*Branch*\n${branchName}`
                          },
                          {
                            type: 'mrkdwn',
                            text: `*Assignee*\n${mention}`
                          }
                        ]
                      },
                      {
                        type: 'section',
                        text: {
                          type: 'mrkdwn',
                          text: `*Issue*\n${sanitizeForSlack(issueTitle)}`
                        }
                      },
                      {
                        type: 'actions',
                        elements: [
                          {
                            type: 'button',
                            text: {
                              type: 'plain_text',
                              text: 'View Issue'
                            },
                            url: issueUrl
                          }
                        ]
                      }
                    ]
                  });
                } catch (error) {
                  console.log('Branch already exists or creation failed');
                }
              }
              
              if (action === 'reopened') {
                await sendToSlack({
                  text: `Issue #${issueNumber} reopened`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'Issue Reopened',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: `*Issue #${issueNumber}*\n${sanitizeForSlack(issueTitle)}`
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Assignee*\n${assignee || 'ÎØ∏ÏßÄÏ†ï'}`
                        }
                      ]
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'View Issue'
                          },
                          url: issueUrl
                        }
                      ]
                    }
                  ]
                });
              }
              
              const hasImportantLabel = labels.some(label => 
                ['urgent', 'critical', 'bug', 'hotfix'].includes(label.toLowerCase())
              );
              
              if (hasImportantLabel && assignee) {
                const slackUserId = userMapping[assignee];
                const mention = slackUserId ? `<@${slackUserId}>` : assignee;
                
                await sendToSlack({
                  text: `Important Issue #${issueNumber} requires attention`,
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'Important Issue Alert',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `${mention} Ï§ëÏöîÌïú IssueÍ∞Ä Ìï†ÎãπÎêòÏóàÏäµÎãàÎã§.`
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: `*Issue #${issueNumber}*\n${sanitizeForSlack(issueTitle)}`
                        },
                        {
                          type: 'mrkdwn',
                          text: `*Labels*\n${labels.join(', ')}`
                        }
                      ]
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'View Issue'
                          },
                          url: issueUrl,
                          style: 'danger'
                        }
                      ]
                    }
                  ]
                });
              }
              
              console.log('‚úÖ Workflow completed');
              
            } catch (error) {
              console.error('‚ùå Workflow failed:', error.message);
              throw error;
            }
