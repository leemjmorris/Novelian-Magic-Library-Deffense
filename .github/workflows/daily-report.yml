name: Daily Report

on:
  workflow_dispatch:  # ÏàòÎèô Ïã§ÌñâÎßå ÏßÄÏõê

permissions:
  contents: read
  issues: read
  pull-requests: read

jobs:
  generate-daily-report:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts/user-mapping.json
          sparse-checkout-cone-mode: false

      - name: Generate Daily Report
        uses: actions/github-script@v7
        env:
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_REPORT_PAGE_ID: ${{ secrets.NOTION_REPORT_PAGE_ID }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          script: |
            const fs = require('fs');
            const https = require('https');

            const now = new Date();
            const kstOffset = 9 * 60 * 60 * 1000;
            const kstDate = new Date(now.getTime() + kstOffset);
            const dayOfWeek = kstDate.getDay();

            // KST 09:00 Í∏∞Ï§ÄÏúºÎ°ú ÏàòÏßë Í∏∞Í∞Ñ ÏÑ§Ï†ï
            // KST 09:00 = UTC 00:00
            const todayKST9AM = new Date(kstDate);
            todayKST9AM.setUTCHours(0, 0, 0, 0); // KST 09:00 = UTC 00:00

            let startDateTime, endDateTime;
            if (dayOfWeek === 1) {
              // ÏõîÏöîÏùº: Í∏àÏöîÏùº 09:00 ~ ÏõîÏöîÏùº 09:00 (3Ïùº)
              startDateTime = new Date(todayKST9AM.getTime() - 3 * 24 * 60 * 60 * 1000);
            } else {
              // ÌèâÏùº: Ï†ÑÎÇ† 09:00 ~ Í∏àÏùº 09:00 (1Ïùº)
              startDateTime = new Date(todayKST9AM.getTime() - 1 * 24 * 60 * 60 * 1000);
            }
            endDateTime = todayKST9AM;

            const startDate = startDateTime.toISOString();
            const endDate = endDateTime.toISOString();
            const today = kstDate.toISOString().split('T')[0];

            const dateStr = kstDate.toLocaleDateString('ko-KR', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              weekday: 'long'
            });

            const periodStr = (dayOfWeek === 1)
              ? '(Ï£ºÎßê Ìè¨Ìï®: Í∏àÏöîÏùº 09:00 ~ ÏõîÏöîÏùº 09:00)'
              : '(Ï†ÑÏùº 09:00 ~ Í∏àÏùº 09:00)';

            // Load user mapping from JSON file
            const userMappingData = JSON.parse(fs.readFileSync('.github/scripts/user-mapping.json', 'utf8'));
            const userNames = {};
            for (const [username, data] of Object.entries(userMappingData)) {
              userNames[username] = data.koreanName;
            }

            function sendToSlack(message) {
              return new Promise((resolve, reject) => {
                if (!process.env.SLACK_WEBHOOK_URL) {
                  console.log('‚ö†Ô∏è SLACK_WEBHOOK_URL not set, skipping Slack notification');
                  resolve('skipped');
                  return;
                }

                const data = JSON.stringify(message);
                const url = new URL(process.env.SLACK_WEBHOOK_URL);

                const options = {
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };

                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200 && body === 'ok') {
                      resolve(body);
                    } else {
                      reject(new Error('Slack API error: ' + res.statusCode));
                    }
                  });
                });

                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }

            async function checkTodayReportExists(parentPageId, todayDateStr) {
              const token = process.env.NOTION_API_TOKEN;

              return new Promise((resolve, reject) => {
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/blocks/' + parentPageId + '/children?page_size=100',
                  method: 'GET',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);

                      if (res.statusCode === 200 && result.results) {
                        // Check if any child page has today's date in the title
                        const existingPage = result.results.find(page => {
                          if (page.type === 'child_page' && page.child_page && page.child_page.title) {
                            return page.child_page.title.includes(todayDateStr);
                          }
                          return false;
                        });

                        resolve(existingPage ? true : false);
                      } else {
                        console.log('‚ö†Ô∏è Failed to check existing pages, proceeding with creation');
                        resolve(false);
                      }
                    } catch (e) {
                      console.error('‚ö†Ô∏è Error checking existing pages:', e);
                      resolve(false);
                    }
                  });
                });

                req.on('error', (e) => {
                  console.error('‚ö†Ô∏è Request error while checking:', e);
                  resolve(false);
                });

                req.end();
              });
            }
            
            function parseAISummaryToBlocks(summary) {
              const blocks = [];
              const lines = summary.split('\n');
              let lastBulletBlock = null;

              for (const line of lines) {
                const trimmed = line.trim();

                if (!trimmed) {
                  continue;
                }

                if (trimmed === '---') {
                  lastBulletBlock = null;
                  blocks.push({
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  });
                } else if (trimmed.startsWith('## ')) {
                  lastBulletBlock = null;
                  const text = trimmed.substring(3).trim();
                  blocks.push({
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: text } }]
                    }
                  });
                } else if (trimmed.startsWith('# ')) {
                  lastBulletBlock = null;
                  const text = trimmed.substring(2).trim();
                  blocks.push({
                    object: 'block',
                    type: 'heading_2',
                    heading_2: {
                      rich_text: [{ text: { content: text } }]
                    }
                  });
                } else if (trimmed.startsWith('- ')) {
                  const text = trimmed.substring(2).trim();
                  const block = {
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [{ text: { content: text } }],
                      children: []
                    }
                  };
                  blocks.push(block);
                  lastBulletBlock = block;
                } else if (trimmed.startsWith('„Ñ¥ ') || trimmed.startsWith('„Ñ¥')) {
                  // Îì§Ïó¨Ïì∞Í∏∞Îêú ÌïòÏúÑ Ìï≠Î™© Ï≤òÎ¶¨
                  const text = trimmed.startsWith('„Ñ¥ ') ? trimmed.substring(2).trim() : trimmed.substring(1).trim();
                  const childBlock = {
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [{ text: { content: text } }]
                    }
                  };

                  if (lastBulletBlock && lastBulletBlock.bulleted_list_item.children) {
                    // Ïù¥Ï†Ñ bulletÏùò childrenÏóê Ï∂îÍ∞Ä
                    lastBulletBlock.bulleted_list_item.children.push(childBlock);
                  } else {
                    // Ïù¥Ï†Ñ bulletÏù¥ ÏóÜÏúºÎ©¥ ÏùºÎ∞ò bulletÏúºÎ°ú Ï∂îÍ∞Ä („Ñ¥ ÌëúÏãú Ïú†ÏßÄ)
                    blocks.push({
                      object: 'block',
                      type: 'bulleted_list_item',
                      bulleted_list_item: {
                        rich_text: [{ text: { content: '„Ñ¥ ' + text } }]
                      }
                    });
                  }
                } else {
                  lastBulletBlock = null;
                  blocks.push({
                    object: 'block',
                    type: 'paragraph',
                    paragraph: {
                      rich_text: [{ text: { content: trimmed } }]
                    }
                  });
                }
              }

              // childrenÏù¥ Îπà Î∞∞Ïó¥Ïù∏ Í≤ΩÏö∞ Ï†úÍ±∞ (Notion API ÏöîÍµ¨ÏÇ¨Ìï≠)
              for (const block of blocks) {
                if (block.bulleted_list_item && block.bulleted_list_item.children && block.bulleted_list_item.children.length === 0) {
                  delete block.bulleted_list_item.children;
                }
              }

              return blocks;
            }
            
            async function generateClaudeSummary(issues, prs, isMonday) {
              const anthropicApiKey = process.env.ANTHROPIC_API_KEY;

              const periodInfo = isMonday ? 'Í∏àÏöîÏùºÎ∂ÄÌÑ∞ ÏõîÏöîÏùºÍπåÏßÄ (Ï£ºÎßê Ìè¨Ìï® 3ÏùºÍ∞Ñ)' : 'Ï†ÑÏùº';

              // Filter only developers (exclude planners)
              const developers = ['leemjmorris', 'jaemoon23', 'LeeChaeBin002'];

              const filteredIssues = issues.filter(issue =>
                issue.assignees.some(assignee => developers.includes(assignee.login))
              );

              const filteredPRs = prs.filter(pr =>
                developers.includes(pr.user.login)
              );

              const filteredIssuesList = filteredIssues.map(issue => {
                const assignees = issue.assignees
                  .filter(a => developers.includes(a.login))
                  .map(a => userNames[a.login] || a.login)
                  .join(', ') || 'ÎØ∏Î∞∞Ï†ï';
                const labels = issue.labels.map(l => l.name).join(', ');
                return '- #' + issue.number + ' ' + issue.title + ' (Îã¥Îãπ: ' + assignees + ') [' + labels + '] - ' + issue.state;
              }).join('\n');

              const filteredPRsList = filteredPRs.map(pr => {
                const author = userNames[pr.user.login] || pr.user.login;
                return '- #' + pr.number + ' ' + pr.title + ' (ÏûëÏÑ±: ' + author + ') - ' + (pr.merged_at ? 'Î®∏ÏßÄÎê®' : pr.state);
              }).join('\n');

              const prompt = 'ÎãπÏã†ÏùÄ Unity Í≤åÏûÑ Í∞úÎ∞ú ÌåÄÏùò ÏùºÏùº Î≥¥Í≥†ÏÑúÎ•º ÏûëÏÑ±ÌïòÎäî AIÏûÖÎãàÎã§.\n' +
                'ÏïÑÎûòÏùò GitHub IssuesÏôÄ Pull Requests Îç∞Ïù¥ÌÑ∞Î•º Î∂ÑÏÑùÌïòÏó¨, Ï†ïÌôïÌûà ÏßÄÏ†ïÎêú ÏñëÏãùÏúºÎ°ú Î≥¥Í≥†ÏÑúÎ•º ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.\n\n' +
                '## ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞\n\n' +
                '**Í∏∞Í∞Ñ:** ' + periodInfo + '\n\n' +
                '**Í∞úÎ∞ú ÌåÄÏõê:**\n' +
                '- Ïù¥Î™ÖÏßÑ (ÌåÄÏû•, ÌîÑÎ°úÍ∑∏ÎûòÎ®∏)\n' +
                '- Ïù¥Ïû¨Î¨∏ (ÌîÑÎ°úÍ∑∏ÎûòÎ®∏)\n' +
                '- Ïù¥Ï±ÑÎπà (ÌîÑÎ°úÍ∑∏ÎûòÎ®∏/ÎîîÏûêÏù¥ÎÑà)\n\n' +
                '**GitHub Issues:**\n' +
                (filteredIssuesList || 'ÏóÜÏùå') + '\n\n' +
                '**Pull Requests:**\n' +
                (filteredPRsList || 'ÏóÜÏùå') + '\n\n' +
                '## Ï∂úÎ†• ÏñëÏãù (Î∞òÎìúÏãú Ïù¥ ÌòïÏãù Í∑∏ÎåÄÎ°ú Ï∂úÎ†•ÌïòÏÑ∏Ïöî)\n\n' +
                '# Ïù¥Ïäà\n' +
                '- ÏóÜÏùå\n\n' +
                '---\n\n' +
                '# Ï†ÑÏùº Î≥¥Í≥†\n' +
                '## ÏôÑÎ£å\n' +
                '- Ïù¥Î™ÖÏßÑ - Ïä§ÌÇ¨ ÏãúÏä§ÌÖú Íµ¨ÌòÑ\n' +
                '„Ñ¥ ÌååÏù¥Ïñ¥Î≥º Ïä§ÌÇ¨ Îã§Ï§ë Ìà¨ÏÇ¨Ï≤¥ Í∏∞Îä• Ï∂îÍ∞Ä\n' +
                '„Ñ¥ Ïä§ÌÑ¥ Ìö®Í≥º Íµ¨ÌòÑ ÏôÑÎ£å\n' +
                '- Ïù¥Ïû¨Î¨∏ - ÏÇ¨ÏÑú Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Ï†úÏûë\n' +
                '„Ñ¥ Ï±ÖÍ∞àÌîº Ïù∏Î≤§ÌÜ†Î¶¨ Ïó∞Îèô ÏôÑÎ£å\n' +
                '„Ñ¥ Ï∫êÎ¶≠ÌÑ∞ ÎèÑÍ∞ê Í∏∞Îä• Íµ¨ÌòÑ\n\n' +
                '## ÎØ∏ÏôÑÎ£å (ÏÇ¨Ïú†, Ï≤òÎ¶¨)\n' +
                '- Ïù¥Î™ÖÏßÑ - Ïä§ÌÇ¨ 25Í∞ú Íµ¨ÌòÑ ÎØ∏ÏôÑÎ£å. ÏãúÍ∞Ñ Î∂ÄÏ°±ÏúºÎ°ú 10Í∞úÎßå ÏôÑÏÑ±.\n\n' +
                '---\n\n' +
                '# Í∏àÏùº Î≥¥Í≥†\n' +
                '## Ïò§Ï†Ñ\n' +
                '- Ïù¥Î™ÖÏßÑ - Ïä§ÌÇ¨ Ï∂îÍ∞Ä Íµ¨ÌòÑ\n' +
                '„Ñ¥ ÎÇ®ÏùÄ 15Í∞ú Ïä§ÌÇ¨ Ï†úÏûë ÏòàÏ†ï\n' +
                '- Ïù¥Ïû¨Î¨∏ - Îç± ÏÑ§Ï†ï ÏãúÏä§ÌÖú Íµ¨ÌòÑ\n\n' +
                '## Ïò§ÌõÑ\n' +
                '- Ïù¥Ï±ÑÎπà - UI ÏûëÏóÖ ÏßÑÌñâ\n' +
                '„Ñ¥ Ïä§ÌÖåÏù¥ÏßÄ ÏÑ†ÌÉù ÌåùÏóÖ ÏôÑÏÑ± ÏòàÏ†ï\n\n' +
                '## (ÏïºÍ∑º)\n' +
                '- ÏóÜÏùå\n\n' +
                '---\n\n' +
                '## ÌïµÏã¨ Í∑úÏπô (Ï†àÎåÄ ÏúÑÎ∞ò Í∏àÏßÄ)\n\n' +
                '1. **ÏûëÏóÖÏûêÎ≥Ñ Í∑∏Î£πÌôî**: Í∞ôÏùÄ ÏûëÏóÖÏûêÎäî Ìïú Î≤àÎßå Ïù¥Î¶ÑÏùÑ Ïì∞Í≥†, ÏÑ∏Î∂Ä ÎÇ¥Ïö©ÏùÄ Î∞òÎìúÏãú "„Ñ¥"Î°ú ÏãúÏûë\n' +
                '2. **Îì§Ïó¨Ïì∞Í∏∞ Î¨∏Ïûê**: ÌïòÏúÑ Ìï≠Î™©ÏùÄ Î∞òÎìúÏãú "„Ñ¥" Î¨∏Ïûê ÏÇ¨Ïö© (- ÏÇ¨Ïö© Í∏àÏßÄ!)\n' +
                '3. **Ïù¥Ïäà ÏÑπÏÖò**: "# Ïù¥Ïäà"Îäî Ìï¥Í≤∞Ìï¥Ïïº Ìï† Î≤ÑÍ∑∏ÎÇò Î¨∏Ï†úÏ†êÎßå Í∏∞Ïû¨. ÏßÑÌñâ Ï§ëÏù∏ FeatureÎäî Í∏∞Ïû¨ÌïòÏßÄ ÏïäÏùå\n' +
                '4. **Ï†úÎ™© Î†àÎ≤®**: # (heading 1), ## (heading 2) Ï†ïÌôïÌûà ÏÇ¨Ïö©\n' +
                '5. **Íµ¨Î∂ÑÏÑ†**: --- ÏÇ¨Ïö©\n' +
                '6. **ÎÇ¥Ïö© ÏöîÏïΩ**: Issue Ï†úÎ™©ÏùÑ Í∑∏ÎåÄÎ°ú Î≥µÏÇ¨ÌïòÏßÄ ÎßêÍ≥†, Ïã§Ï†ú ÏûëÏóÖ ÎÇ¥Ïö©ÏùÑ ÏûêÏó∞Ïä§ÎüΩÍ≤å ÏöîÏïΩ\n' +
                '7. **ÏóÜÎäî Ìï≠Î™©**: Ìï¥Îãπ ÏÑπÏÖòÏóê ÎÇ¥Ïö©Ïù¥ ÏóÜÏúºÎ©¥ "- ÏóÜÏùå" ÌëúÏãú\n' +
                (isMonday ? '8. Ï£ºÎßê(Í∏à~Ïùº) ÏûëÏóÖ ÎÇ¥Ïö©ÏùÑ Î™®Îëê Î∞òÏòÅÌïòÏÑ∏Ïöî.\n' : '') +
                '\nÏúÑ ÏñëÏãùÍ≥º Í∑úÏπôÏùÑ Ï†ïÌôïÌûà Îî∞Îùº Î≥¥Í≥†ÏÑúÎ•º ÏûëÏÑ±ÌïòÏÑ∏Ïöî. ÏñëÏãù Ïô∏Ïùò Ï∂îÍ∞Ä ÏÑ§Î™ÖÏù¥ÎÇò Ï£ºÏÑùÏùÄ ÎÑ£ÏßÄ ÎßàÏÑ∏Ïöî.';

              return new Promise((resolve, reject) => {
                const postData = JSON.stringify({
                  model: 'claude-3-haiku-20240307',
                  max_tokens: 4096,
                  messages: [{
                    role: 'user',
                    content: prompt
                  }]
                });

                const req = https.request({
                  hostname: 'api.anthropic.com',
                  path: '/v1/messages',
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': anthropicApiKey,
                    'anthropic-version': '2023-06-01'
                  }
                }, (res) => {
                  console.log('üîç Claude API Status:', res.statusCode);

                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);

                      if (result.content && result.content[0] && result.content[0].text) {
                        console.log('‚úÖ AI summary generated successfully');
                        resolve(result.content[0].text);
                      } else if (result.error) {
                        console.error('‚ùå Claude API Error:', result.error);
                        reject(new Error('Claude API error: ' + result.error.message));
                      } else {
                        console.error('‚ùå Unexpected response structure:', JSON.stringify(result));
                        reject(new Error('Invalid Claude API response structure'));
                      }
                    } catch (e) {
                      console.error('‚ùå Failed to parse Claude response:', body);
                      reject(e);
                    }
                  });
                });

                req.on('error', (e) => {
                  console.error('‚ùå Claude request error:', e);
                  reject(e);
                });

                req.write(postData);
                req.end();
              });
            }
            
            async function createNotionPage() {
              const token = process.env.NOTION_API_TOKEN;
              const parentPageId = process.env.NOTION_REPORT_PAGE_ID;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  parent: { page_id: parentPageId },
                  icon: { emoji: 'üìä' },
                  properties: {
                    title: {
                      title: [{ text: { content: dateStr + ' Í∞úÎ∞ú ÌòÑÌô© ' + periodStr } }]
                    }
                  }
                });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (res.statusCode === 200) {
                        console.log('üìÑ Page created:', result.url);
                        resolve(result);
                      } else {
                        console.error('‚ùå Notion API Error:', JSON.stringify(result, null, 2));
                        reject(new Error('Notion API returned ' + res.statusCode + ': ' + (result.message || 'Unknown error')));
                      }
                    } catch (e) {
                      console.error('‚ùå Failed to parse response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('‚ùå Request error:', e);
                  reject(e);
                });
                
                req.write(data);
                req.end();
              });
            }
            
            async function appendBlocksToNotion(pageId, blocks) {
              const token = process.env.NOTION_API_TOKEN;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({ children: blocks });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/blocks/' + pageId + '/children',
                  method: 'PATCH',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (res.statusCode === 200) {
                        resolve(result);
                      } else {
                        console.error('‚ùå Notion API Error:', JSON.stringify(result, null, 2));
                        reject(new Error('Notion API returned ' + res.statusCode + ': ' + (result.message || 'Unknown error')));
                      }
                    } catch (e) {
                      console.error('‚ùå Failed to parse response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('‚ùå Request error:', e);
                  reject(e);
                });
                
                req.write(data);
                req.end();
              });
            }
            
            try {
              console.log('Generating daily report for ' + dateStr + '...');
              console.log('Collection period: ' + startDate + ' ~ ' + endDate);

              // Check if today's report already exists
              const parentPageId = process.env.NOTION_REPORT_PAGE_ID;
              console.log('üîç Checking if today\'s report already exists...');
              const reportExists = await checkTodayReportExists(parentPageId, dateStr);

              if (reportExists) {
                console.log('‚úÖ Today\'s report already exists. Skipping to prevent duplicate.');
                console.log('üìå Report date: ' + dateStr);
                return;
              }

              console.log('‚úÖ No existing report found. Proceeding with creation...');

              // Fetch all issues once (both open and closed)
              const [allIssuesResponse, allPRsResponse] = await Promise.all([
                github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  since: startDate,
                  state: 'all',
                  per_page: 100
                }),
                github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  sort: 'created',
                  direction: 'desc',
                  per_page: 100
                })
              ]);

              const startDateObj = new Date(startDate);

              // Filter issues from the single API call
              const allIssues = allIssuesResponse.data.filter(issue => !issue.pull_request);
              const newIssues = allIssues.filter(issue => new Date(issue.created_at) >= startDateObj);
              const closedIssues = allIssues.filter(issue =>
                issue.state === 'closed' &&
                issue.closed_at &&
                new Date(issue.closed_at) >= startDateObj
              );
              const inProgressIssues = allIssues.filter(issue =>
                issue.state === 'open' &&
                issue.assignees.length > 0
              );

              // Filter PRs from the single API call
              const newPRs = allPRsResponse.data.filter(pr => new Date(pr.created_at) >= startDateObj);
              const mergedPRs = allPRsResponse.data.filter(pr =>
                pr.merged_at &&
                new Date(pr.merged_at) >= startDateObj
              );

              const allRecentIssues = allIssues;
              
              // Filter only developers for AI summary
              const developers = ['leemjmorris', 'jaemoon23', 'LeeChaeBin002'];

              console.log('ü§ñ Generating AI summary with Claude...');
              const aiSummary = await generateClaudeSummary(allRecentIssues, allPRsResponse.data, dayOfWeek === 1);
              console.log('‚úÖ AI summary generated');

              const userStats = {};

              for (const issue of inProgressIssues) {
                for (const assignee of issue.assignees) {
                  // Only count developers
                  if (!developers.includes(assignee.login)) continue;

                  const userName = userNames[assignee.login] || assignee.login;
                  if (!userStats[userName]) {
                    userStats[userName] = {
                      inProgress: 0,
                      completed: 0,
                      prs: 0
                    };
                  }
                  userStats[userName].inProgress++;
                }
              }

              for (const issue of closedIssues) {
                for (const assignee of issue.assignees) {
                  // Only count developers
                  if (!developers.includes(assignee.login)) continue;

                  const userName = userNames[assignee.login] || assignee.login;
                  if (!userStats[userName]) {
                    userStats[userName] = {
                      inProgress: 0,
                      completed: 0,
                      prs: 0
                    };
                  }
                  userStats[userName].completed++;
                }
              }

              for (const pr of mergedPRs) {
                // Only count developers
                if (!developers.includes(pr.user.login)) continue;

                const userName = userNames[pr.user.login] || pr.user.login;
                if (!userStats[userName]) {
                  userStats[userName] = {
                    inProgress: 0,
                    completed: 0,
                    prs: 0
                  };
                }
                userStats[userName].prs++;
              }
              
              const blocks = [];
              
              blocks.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ text: { content: 'ü§ñ AI ÏöîÏïΩ' } }]
                }
              });
              
              const aiBlocks = parseAISummaryToBlocks(aiSummary);
              blocks.push(...aiBlocks);
              
              blocks.push(
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'heading_2',
                  heading_2: {
                    rich_text: [{ text: { content: 'üìä ÏùºÏùº Í∞úÎ∞ú ÌòÑÌô©' } }]
                  }
                },
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'heading_3',
                  heading_3: {
                    rich_text: [{ text: { content: 'üìà ÌÜµÍ≥Ñ ÏöîÏïΩ' } }]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ÏÉùÏÑ±Îêú Issue: ' } },
                      { text: { content: newIssues.length + 'Í∞ú' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ÏôÑÎ£åÎêú Issue: ' } },
                      { text: { content: closedIssues.length + 'Í∞ú' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ÏÉùÏÑ±Îêú PR: ' } },
                      { text: { content: newPRs.length + 'Í∞ú' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'Î®∏ÏßÄÎêú PR: ' } },
                      { text: { content: mergedPRs.length + 'Í∞ú' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ÏßÑÌñâ Ï§ëÏù∏ Issue: ' } },
                      { text: { content: inProgressIssues.length + 'Í∞ú' }, annotations: { bold: true } }
                    ]
                  }
                }
              );
              
              if (Object.keys(userStats).length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'üë• ÌåÄÏõêÎ≥Ñ ÌòÑÌô©' } }]
                    }
                  }
                );
                
                for (const [userName, stats] of Object.entries(userStats)) {
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { text: { content: userName + ': ' }, annotations: { bold: true } },
                        { text: { content: 'ÏßÑÌñâÏ§ë ' + stats.inProgress + 'Í∞ú ' } },
                        { text: { content: '/ ' }, annotations: { color: 'gray' } },
                        { text: { content: 'ÏôÑÎ£å ' + stats.completed + 'Í∞ú ' } },
                        { text: { content: '/ ' }, annotations: { color: 'gray' } },
                        { text: { content: 'PR ' + stats.prs + 'Í∞ú' } }
                      ]
                    }
                  });
                }
              }
              
              // Filter new issues for developers only
              const developerNewIssues = newIssues.filter(issue =>
                issue.assignees.some(a => developers.includes(a.login))
              );

              if (developerNewIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'üÜï ÏÉùÏÑ±Îêú Issue' } }]
                    }
                  }
                );

                for (const issue of developerNewIssues) {
                  const assigneeNames = issue.assignees
                    .filter(a => developers.includes(a.login))
                    .map(a => userNames[a.login] || a.login)
                    .join(', ') || 'ÎØ∏Î∞∞Ï†ï';

                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        {
                          text: {
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: issue.title + ' ' } },
                        { text: { content: '(Îã¥Îãπ: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              // Filter closed issues for developers only
              const developerClosedIssues = closedIssues.filter(issue =>
                issue.assignees.some(a => developers.includes(a.login))
              );

              if (developerClosedIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: '‚úÖ ÏôÑÎ£åÎêú Issue' } }]
                    }
                  }
                );

                for (const issue of developerClosedIssues) {
                  const assigneeNames = issue.assignees
                    .filter(a => developers.includes(a.login))
                    .map(a => userNames[a.login] || a.login)
                    .join(', ') || 'ÎØ∏Î∞∞Ï†ï';

                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        {
                          text: {
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true, strikethrough: true }
                        },
                        { text: { content: issue.title + ' ' }, annotations: { strikethrough: true } },
                        { text: { content: '(Îã¥Îãπ: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              // Filter merged PRs for developers only
              const developerMergedPRs = mergedPRs.filter(pr =>
                developers.includes(pr.user.login)
              );

              if (developerMergedPRs.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'üîÄ Î®∏ÏßÄÎêú PR' } }]
                    }
                  }
                );

                for (const pr of developerMergedPRs) {
                  const authorName = userNames[pr.user.login] || pr.user.login;

                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        {
                          text: {
                            content: '#' + pr.number + ' ',
                            link: { url: pr.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: pr.title + ' ' } },
                        { text: { content: '(ÏûëÏÑ±Ïûê: ' + authorName + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              // Filter in-progress issues for developers only
              const developerInProgressIssues = inProgressIssues.filter(issue =>
                issue.assignees.some(a => developers.includes(a.login))
              );

              if (developerInProgressIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'üîÑ ÏßÑÌñâ Ï§ëÏù∏ Issue' } }]
                    }
                  }
                );

                for (const issue of developerInProgressIssues.slice(0, 20)) {
                  const assigneeNames = issue.assignees
                    .filter(a => developers.includes(a.login))
                    .map(a => userNames[a.login] || a.login)
                    .join(', ');

                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        {
                          text: {
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: issue.title + ' ' } },
                        { text: { content: '(Îã¥Îãπ: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }

                if (developerInProgressIssues.length > 20) {
                  blocks.push({
                    object: 'block',
                    type: 'paragraph',
                    paragraph: {
                      rich_text: [
                        { text: { content: '... Ïô∏ ' + (developerInProgressIssues.length - 20) + 'Í∞ú' }, annotations: { italic: true, color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              blocks.push(
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'paragraph',
                  paragraph: {
                    rich_text: [
                      { text: { content: 'ü§ñ Ïù¥ Î¶¨Ìè¨Ìä∏Îäî GitHub ActionsÏóê ÏùòÌï¥ ÏûêÎèôÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.' }, annotations: { italic: true, color: 'gray' } }
                    ]
                  }
                }
              );
              
              console.log('üì§ Creating Notion page...');
              const page = await createNotionPage();
              const pageId = page.id;

              console.log('üìù Total blocks to add:', blocks.length);

              // Notion has a limit of ~2000 blocks per page
              const MAX_BLOCKS = 1900;
              if (blocks.length > MAX_BLOCKS) {
                console.log('‚ö†Ô∏è Warning: Block count (' + blocks.length + ') exceeds recommended limit (' + MAX_BLOCKS + ')');
                console.log('‚ö†Ô∏è Truncating to ' + MAX_BLOCKS + ' blocks to prevent errors');
                blocks.splice(MAX_BLOCKS);
                blocks.push({
                  object: 'block',
                  type: 'callout',
                  callout: {
                    rich_text: [{
                      text: {
                        content: '‚ö†Ô∏è ÏùºÎ∂Ä Ìï≠Î™©Ïù¥ ÏÉùÎûµÎêòÏóàÏäµÎãàÎã§. Ï†ÑÏ≤¥ ÎÇ¥Ïö©ÏùÄ GitHubÏóêÏÑú ÌôïÏù∏ÌïòÏÑ∏Ïöî.'
                      }
                    }],
                    icon: { emoji: '‚ö†Ô∏è' },
                    color: 'yellow_background'
                  }
                });
              }

              // Notion API allows max 100 blocks per request
              for (let i = 0; i < blocks.length; i += 100) {
                const chunk = blocks.slice(i, i + 100);
                console.log('üì§ Adding blocks ' + (i + 1) + '-' + (i + chunk.length) + '...');
                await appendBlocksToNotion(pageId, chunk);
              }
              
              console.log('‚úÖ Daily report added to Notion');
              console.log('‚úÖ Daily report generation completed');

              console.log('üì® Sending Slack notification...');
              try {
                const notionPageUrl = page.url;

                const slackMessage = {
                  text: 'ÏùºÍ∞Ñ Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏôÑÎ£å',
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'üìä ÏùºÍ∞Ñ Î≥¥Í≥†ÏÑú ÏÉùÏÑ± ÏôÑÎ£å',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: '*ÎÇ†Ïßú*\n' + dateStr + ' ' + periodStr
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ÏÉùÏÑ± ÏãúÍ∞Ñ*\n' + new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })
                        }
                      ]
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: '*ÏÉà Ïù¥Ïäà*\n' + developerNewIssues.length + 'Í∞ú'
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ÏôÑÎ£å Ïù¥Ïäà*\n' + developerClosedIssues.length + 'Í∞ú'
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ÏÉà PR*\n' + newPRs.filter(pr => developers.includes(pr.user.login)).length + 'Í∞ú'
                        },
                        {
                          type: 'mrkdwn',
                          text: '*Î®∏ÏßÄ PR*\n' + developerMergedPRs.length + 'Í∞ú'
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: 'üìÑ *ÏÉÅÏÑ∏ Î≥¥Í≥†ÏÑú*\nNotionÏóêÏÑú ÌôïÏù∏ÌïòÏÑ∏Ïöî'
                      }
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'NotionÏóêÏÑú Î≥¥Í∏∞',
                            emoji: true
                          },
                          url: notionPageUrl,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                };

                await sendToSlack(slackMessage);
                console.log('‚úÖ Slack notification sent');
              } catch (slackError) {
                console.error('‚ö†Ô∏è Failed to send Slack notification:', slackError.message);
              }

            } catch (error) {
              console.error('‚ùå Error:', error);

              try {
                const errorMessage = {
                  text: 'ÏùºÍ∞Ñ Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ïã§Ìå®',
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: '‚ùå ÏùºÍ∞Ñ Î≥¥Í≥†ÏÑú ÏÉùÏÑ± Ïã§Ìå®',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: '*ÎÇ†Ïßú*\n' + dateStr
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: '*Ïò§Î•ò Î©îÏãúÏßÄ*\n```' + error.message + '```'
                      }
                    }
                  ]
                };

                await sendToSlack(errorMessage);
              } catch (slackError) {
                console.error('‚ö†Ô∏è Failed to send error notification to Slack:', slackError.message);
              }

              throw error;
            }
