name: Daily Report

on:
  schedule:
    - cron: '30 0 * * 1-5'  # KST 09:30 (1ì°¨ ì‹œë„)
    - cron: '0 1 * * 1-5'   # KST 10:00 (2ì°¨ ì‹œë„, 1ì°¨ ì‹¤íŒ¨ ì‹œ ë°±ì—…)
  workflow_dispatch:

permissions:
  contents: read
  issues: read
  pull-requests: read

jobs:
  generate-daily-report:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts/user-mapping.json
          sparse-checkout-cone-mode: false

      - name: Generate Daily Report
        uses: actions/github-script@v7
        env:
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_REPORT_PAGE_ID: ${{ secrets.NOTION_REPORT_PAGE_ID }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          script: |
            const fs = require('fs');
            const https = require('https');

            const now = new Date();
            const kstOffset = 9 * 60 * 60 * 1000;
            const kstDate = new Date(now.getTime() + kstOffset);
            const dayOfWeek = kstDate.getDay();

            const daysToLookBack = (dayOfWeek === 1) ? 3 : 1;
            const startDate = new Date(kstDate.getTime() - daysToLookBack * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const today = kstDate.toISOString().split('T')[0];

            const dateStr = kstDate.toLocaleDateString('ko-KR', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              weekday: 'long'
            });

            const periodStr = (dayOfWeek === 1)
              ? '(ì£¼ë§ í¬í•¨)'
              : '';

            // Load user mapping from JSON file
            const userMappingData = JSON.parse(fs.readFileSync('.github/scripts/user-mapping.json', 'utf8'));
            const userNames = {};
            for (const [username, data] of Object.entries(userMappingData)) {
              userNames[username] = data.koreanName;
            }

            function sendToSlack(message) {
              return new Promise((resolve, reject) => {
                if (!process.env.SLACK_WEBHOOK_URL) {
                  console.log('âš ï¸ SLACK_WEBHOOK_URL not set, skipping Slack notification');
                  resolve('skipped');
                  return;
                }

                const data = JSON.stringify(message);
                const url = new URL(process.env.SLACK_WEBHOOK_URL);

                const options = {
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };

                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200 && body === 'ok') {
                      resolve(body);
                    } else {
                      reject(new Error('Slack API error: ' + res.statusCode));
                    }
                  });
                });

                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }

            async function checkTodayReportExists(parentPageId, todayDateStr) {
              const token = process.env.NOTION_API_TOKEN;

              return new Promise((resolve, reject) => {
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/blocks/' + parentPageId + '/children?page_size=100',
                  method: 'GET',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);

                      if (res.statusCode === 200 && result.results) {
                        // Check if any child page has today's date in the title
                        const existingPage = result.results.find(page => {
                          if (page.type === 'child_page' && page.child_page && page.child_page.title) {
                            return page.child_page.title.includes(todayDateStr);
                          }
                          return false;
                        });

                        resolve(existingPage ? true : false);
                      } else {
                        console.log('âš ï¸ Failed to check existing pages, proceeding with creation');
                        resolve(false);
                      }
                    } catch (e) {
                      console.error('âš ï¸ Error checking existing pages:', e);
                      resolve(false);
                    }
                  });
                });

                req.on('error', (e) => {
                  console.error('âš ï¸ Request error while checking:', e);
                  resolve(false);
                });

                req.end();
              });
            }
            
            function parseAISummaryToBlocks(summary) {
              const blocks = [];
              const lines = summary.split('\n');
              
              for (const line of lines) {
                const trimmed = line.trim();
                
                if (!trimmed) {
                  continue;
                }
                
                if (trimmed === '---') {
                  blocks.push({
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  });
                } else if (trimmed.startsWith('## ')) {
                  const text = trimmed.substring(3).trim();
                  blocks.push({
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: text } }]
                    }
                  });
                } else if (trimmed.startsWith('# ')) {
                  const text = trimmed.substring(2).trim();
                  blocks.push({
                    object: 'block',
                    type: 'heading_2',
                    heading_2: {
                      rich_text: [{ text: { content: text } }]
                    }
                  });
                } else if (trimmed.startsWith('- ')) {
                  const text = trimmed.substring(2).trim();
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [{ text: { content: text } }]
                    }
                  });
                } else {
                  blocks.push({
                    object: 'block',
                    type: 'paragraph',
                    paragraph: {
                      rich_text: [{ text: { content: trimmed } }]
                    }
                  });
                }
              }
              
              return blocks;
            }
            
            async function generateGeminiSummary(issues, prs, isMonday) {
              const geminiApiKey = process.env.GEMINI_API_KEY;
              
              const issuesList = issues.map(issue => {
                const assignees = issue.assignees.map(a => userNames[a.login] || a.login).join(', ') || 'ë¯¸ë°°ì •';
                const labels = issue.labels.map(l => l.name).join(', ');
                return '- #' + issue.number + ' ' + issue.title + ' (ë‹´ë‹¹: ' + assignees + ') [' + labels + '] - ' + issue.state;
              }).join('\n');
              
              const prsList = prs.map(pr => {
                const author = userNames[pr.user.login] || pr.user.login;
                return '- #' + pr.number + ' ' + pr.title + ' (ì‘ì„±: ' + author + ') - ' + (pr.merged_at ? 'ë¨¸ì§€ë¨' : pr.state);
              }).join('\n');
              
              const periodInfo = isMonday ? 'ê¸ˆìš”ì¼ë¶€í„° ì›”ìš”ì¼ê¹Œì§€ (ì£¼ë§ í¬í•¨ 3ì¼ê°„)' : 'ì „ì¼';
              
              const prompt = 'ë‹¹ì‹ ì€ Unity ê²Œì„ ê°œë°œ íŒ€ì˜ ì¼ì¼ ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ëŠ” AIì…ë‹ˆë‹¤.\n' +
                'ì•„ë˜ì˜ GitHub Issuesì™€ Pull Requestsë¥¼ ë¶„ì„í•˜ì—¬, íŒ€ì›ë³„ ì‘ì—… ë‚´ìš©ì„ ìš”ì•½í•´ì£¼ì„¸ìš”.\n' +
                '**ê¸°ê°„: ' + periodInfo + 'ì˜ ì‘ì—… ë‚´ìš©**\n\n' +
                '**íŒ€ì› ëª©ë¡:**\n' +
                '- ì´ëª…ì§„ (íŒ€ì¥, í”„ë¡œê·¸ë˜ë¨¸)\n' +
                '- ì´ì¬ë¬¸ (í”„ë¡œê·¸ë˜ë¨¸)\n' +
                '- ì´ì±„ë¹ˆ (í”„ë¡œê·¸ë˜ë¨¸/ë””ìì´ë„ˆ)\n' +
                '- ê¹€ë™ìš± (ê¸°íšì)\n' +
                '- ê¹€ë¯¼íœ˜ (ê¸°íšì)\n' +
                '- ê¹€ì§€ì› (ê¸°íšì)\n\n' +
                '**GitHub Issues (' + periodInfo + '):**\n' +
                (issuesList || 'ì—†ìŒ') + '\n\n' +
                '**Pull Requests (' + periodInfo + '):**\n' +
                (prsList || 'ì—†ìŒ') + '\n\n' +
                '**ì¤‘ìš”: ë‹¤ìŒ í˜•ì‹ì„ ì •í™•íˆ ë”°ë¼ì£¼ì„¸ìš”. ì´ìŠˆ ëª©ë¡ì€ í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”:**\n\n' +
                '# ì „ì¼ ë³´ê³ \n' +
                '## ì™„ë£Œ\n' +
                '- ë‹´ë‹¹ì - ì™„ë£Œí•œ ì‘ì—… ë‚´ìš©\n\n' +
                '## ë¯¸ì™„ë£Œ (ì‚¬ìœ , ì²˜ë¦¬)\n' +
                '- ë‹´ë‹¹ì - ë¯¸ì™„ë£Œ ì‘ì—… ë° ì‚¬ìœ \n\n' +
                '---\n\n' +
                '# ê¸ˆì¼ ë³´ê³ \n' +
                '## ì˜¤ì „\n' +
                '- ë‹´ë‹¹ì - ì˜¤ì „ ì‘ì—… ê³„íš\n\n' +
                '## ì˜¤í›„\n' +
                '- ë‹´ë‹¹ì - ì˜¤í›„ ì‘ì—… ê³„íš\n\n' +
                '## (ì•¼ê·¼)\n' +
                '- ë‹´ë‹¹ì - ì•¼ê·¼ ì‘ì—… ê³„íš (ìˆëŠ” ê²½ìš°ì—ë§Œ)\n\n' +
                '**ì‘ì„± ê·œì¹™:**\n' +
                '1. ë°˜ë“œì‹œ ìœ„ì˜ í˜•ì‹ë§Œ ì‚¬ìš©í•˜ì„¸ìš”. "# ì´ìŠˆ" ì„¹ì…˜ì€ ì ˆëŒ€ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.\n' +
                '2. ì œëª©ì€ ë°˜ë“œì‹œ # ë˜ëŠ” ##ë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤.\n' +
                '3. Issueì˜ labelê³¼ ìƒíƒœ(open/closed)ë¥¼ ì°¸ê³ í•˜ì—¬ ì‘ì—… ì™„ë£Œ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ì„¸ìš”.\n' +
                '4. PRì˜ merge ì—¬ë¶€ë¥¼ ì°¸ê³ í•˜ì—¬ ì‘ì—… ì™„ë£Œë¥¼ íŒë‹¨í•˜ì„¸ìš”.\n' +
                '5. ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ ì‘ì„±í•˜ì„¸ìš”.\n' +
                '6. ì‘ì—… ë‚´ìš©ì´ ì—†ìœ¼ë©´ "ì—†ìŒ"ì´ë¼ê³  í‘œì‹œí•˜ì„¸ìš”.\n' +
                '7. ê° í•­ëª©ì€ "- ë‹´ë‹¹ì - ì‘ì—…ë‚´ìš©" í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš”.\n' +
                (isMonday ? '8. ì£¼ë§ ì‘ì—… ë‚´ìš©ë„ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, ê¸ˆìš”ì¼~ì¼ìš”ì¼ì˜ ì‘ì—…ì„ ëª¨ë‘ ë°˜ì˜í•˜ì„¸ìš”.\n' : '') +
                '\nìš”ì•½ì„ ì‹œì‘í•˜ì„¸ìš”:';

              return new Promise((resolve, reject) => {
                const postData = JSON.stringify({
                  contents: [{
                    parts: [{ text: prompt }]
                  }]
                });
                
                const req = https.request({
                  hostname: 'generativelanguage.googleapis.com',
                  path: '/v1beta/models/gemini-2.5-flash:generateContent?key=' + geminiApiKey,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(postData)
                  }
                }, (res) => {
                  console.log('ğŸ” Gemini API Status:', res.statusCode);
                  
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0] && result.candidates[0].content.parts[0].text) {
                        console.log('âœ… AI summary generated successfully');
                        resolve(result.candidates[0].content.parts[0].text);
                      } else if (result.error) {
                        console.error('âŒ Gemini API Error:', result.error);
                        reject(new Error('Gemini API error: ' + result.error.message));
                      } else {
                        console.error('âŒ Unexpected response structure:', JSON.stringify(result));
                        reject(new Error('Invalid Gemini API response structure'));
                      }
                    } catch (e) {
                      console.error('âŒ Failed to parse Gemini response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('âŒ Gemini request error:', e);
                  reject(e);
                });
                
                req.write(postData);
                req.end();
              });
            }
            
            async function createNotionPage() {
              const token = process.env.NOTION_API_TOKEN;
              const parentPageId = process.env.NOTION_REPORT_PAGE_ID;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  parent: { page_id: parentPageId },
                  icon: { emoji: 'ğŸ“Š' },
                  properties: {
                    title: {
                      title: [{ text: { content: dateStr + ' ê°œë°œ í˜„í™© ' + periodStr } }]
                    }
                  }
                });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (res.statusCode === 200) {
                        console.log('ğŸ“„ Page created:', result.url);
                        resolve(result);
                      } else {
                        console.error('âŒ Notion API Error:', JSON.stringify(result, null, 2));
                        reject(new Error('Notion API returned ' + res.statusCode + ': ' + (result.message || 'Unknown error')));
                      }
                    } catch (e) {
                      console.error('âŒ Failed to parse response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('âŒ Request error:', e);
                  reject(e);
                });
                
                req.write(data);
                req.end();
              });
            }
            
            async function appendBlocksToNotion(pageId, blocks) {
              const token = process.env.NOTION_API_TOKEN;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({ children: blocks });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/blocks/' + pageId + '/children',
                  method: 'PATCH',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (res.statusCode === 200) {
                        resolve(result);
                      } else {
                        console.error('âŒ Notion API Error:', JSON.stringify(result, null, 2));
                        reject(new Error('Notion API returned ' + res.statusCode + ': ' + (result.message || 'Unknown error')));
                      }
                    } catch (e) {
                      console.error('âŒ Failed to parse response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('âŒ Request error:', e);
                  reject(e);
                });
                
                req.write(data);
                req.end();
              });
            }
            
            try {
              console.log('Generating daily report for ' + dateStr + '...');
              console.log('Looking back ' + daysToLookBack + ' days (since ' + startDate + ')');

              // Check if today's report already exists
              const parentPageId = process.env.NOTION_REPORT_PAGE_ID;
              console.log('ğŸ” Checking if today\'s report already exists...');
              const reportExists = await checkTodayReportExists(parentPageId, dateStr);

              if (reportExists) {
                console.log('âœ… Today\'s report already exists. Skipping to prevent duplicate.');
                console.log('ğŸ“Œ Report date: ' + dateStr);
                return;
              }

              console.log('âœ… No existing report found. Proceeding with creation...');

              // Fetch all issues once (both open and closed)
              const [allIssuesResponse, allPRsResponse] = await Promise.all([
                github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  since: startDate,
                  state: 'all',
                  per_page: 100
                }),
                github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  sort: 'created',
                  direction: 'desc',
                  per_page: 100
                })
              ]);

              const startDateObj = new Date(startDate);

              // Filter issues from the single API call
              const allIssues = allIssuesResponse.data.filter(issue => !issue.pull_request);
              const newIssues = allIssues.filter(issue => new Date(issue.created_at) >= startDateObj);
              const closedIssues = allIssues.filter(issue =>
                issue.state === 'closed' &&
                issue.closed_at &&
                new Date(issue.closed_at) >= startDateObj
              );
              const inProgressIssues = allIssues.filter(issue =>
                issue.state === 'open' &&
                issue.assignees.length > 0
              );

              // Filter PRs from the single API call
              const newPRs = allPRsResponse.data.filter(pr => new Date(pr.created_at) >= startDateObj);
              const mergedPRs = allPRsResponse.data.filter(pr =>
                pr.merged_at &&
                new Date(pr.merged_at) >= startDateObj
              );

              const allRecentIssues = allIssues;
              
              console.log('ğŸ¤– Generating AI summary with Gemini...');
              const aiSummary = await generateGeminiSummary(allRecentIssues, allPRsResponse.data, dayOfWeek === 1);
              console.log('âœ… AI summary generated');
              
              const userStats = {};
              
              for (const issue of inProgressIssues) {
                for (const assignee of issue.assignees) {
                  const userName = userNames[assignee.login] || assignee.login;
                  if (!userStats[userName]) {
                    userStats[userName] = {
                      inProgress: 0,
                      completed: 0,
                      prs: 0
                    };
                  }
                  userStats[userName].inProgress++;
                }
              }
              
              for (const issue of closedIssues) {
                for (const assignee of issue.assignees) {
                  const userName = userNames[assignee.login] || assignee.login;
                  if (!userStats[userName]) {
                    userStats[userName] = {
                      inProgress: 0,
                      completed: 0,
                      prs: 0
                    };
                  }
                  userStats[userName].completed++;
                }
              }
              
              for (const pr of mergedPRs) {
                const userName = userNames[pr.user.login] || pr.user.login;
                if (!userStats[userName]) {
                  userStats[userName] = {
                    inProgress: 0,
                    completed: 0,
                    prs: 0
                  };
                }
                userStats[userName].prs++;
              }
              
              const blocks = [];
              
              blocks.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ text: { content: 'ğŸ¤– AI ìš”ì•½' } }]
                }
              });
              
              const aiBlocks = parseAISummaryToBlocks(aiSummary);
              blocks.push(...aiBlocks);
              
              blocks.push(
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'heading_2',
                  heading_2: {
                    rich_text: [{ text: { content: 'ğŸ“Š ì¼ì¼ ê°œë°œ í˜„í™©' } }]
                  }
                },
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'heading_3',
                  heading_3: {
                    rich_text: [{ text: { content: 'ğŸ“ˆ í†µê³„ ìš”ì•½' } }]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ìƒì„±ëœ Issue: ' } },
                      { text: { content: newIssues.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ì™„ë£Œëœ Issue: ' } },
                      { text: { content: closedIssues.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ìƒì„±ëœ PR: ' } },
                      { text: { content: newPRs.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ë¨¸ì§€ëœ PR: ' } },
                      { text: { content: mergedPRs.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ì§„í–‰ ì¤‘ì¸ Issue: ' } },
                      { text: { content: inProgressIssues.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                }
              );
              
              if (Object.keys(userStats).length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ‘¥ íŒ€ì›ë³„ í˜„í™©' } }]
                    }
                  }
                );
                
                for (const [userName, stats] of Object.entries(userStats)) {
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { text: { content: userName + ': ' }, annotations: { bold: true } },
                        { text: { content: 'ì§„í–‰ì¤‘ ' + stats.inProgress + 'ê°œ ' } },
                        { text: { content: '/ ' }, annotations: { color: 'gray' } },
                        { text: { content: 'ì™„ë£Œ ' + stats.completed + 'ê°œ ' } },
                        { text: { content: '/ ' }, annotations: { color: 'gray' } },
                        { text: { content: 'PR ' + stats.prs + 'ê°œ' } }
                      ]
                    }
                  });
                }
              }
              
              if (newIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ†• ìƒì„±ëœ Issue' } }]
                    }
                  }
                );
                
                for (const issue of newIssues) {
                  const assigneeNames = issue.assignees.map(a => 
                    userNames[a.login] || a.login
                  ).join(', ') || 'ë¯¸ë°°ì •';
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: issue.title + ' ' } },
                        { text: { content: '(ë‹´ë‹¹: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              if (closedIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'âœ… ì™„ë£Œëœ Issue' } }]
                    }
                  }
                );
                
                for (const issue of closedIssues) {
                  const assigneeNames = issue.assignees.map(a => 
                    userNames[a.login] || a.login
                  ).join(', ') || 'ë¯¸ë°°ì •';
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true, strikethrough: true }
                        },
                        { text: { content: issue.title + ' ' }, annotations: { strikethrough: true } },
                        { text: { content: '(ë‹´ë‹¹: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              if (mergedPRs.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ”€ ë¨¸ì§€ëœ PR' } }]
                    }
                  }
                );
                
                for (const pr of mergedPRs) {
                  const authorName = userNames[pr.user.login] || pr.user.login;
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + pr.number + ' ',
                            link: { url: pr.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: pr.title + ' ' } },
                        { text: { content: '(ì‘ì„±ì: ' + authorName + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              if (inProgressIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ”„ ì§„í–‰ ì¤‘ì¸ Issue' } }]
                    }
                  }
                );
                
                for (const issue of inProgressIssues.slice(0, 20)) {
                  const assigneeNames = issue.assignees.map(a => 
                    userNames[a.login] || a.login
                  ).join(', ');
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: issue.title + ' ' } },
                        { text: { content: '(ë‹´ë‹¹: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
                
                if (inProgressIssues.length > 20) {
                  blocks.push({
                    object: 'block',
                    type: 'paragraph',
                    paragraph: {
                      rich_text: [
                        { text: { content: '... ì™¸ ' + (inProgressIssues.length - 20) + 'ê°œ' }, annotations: { italic: true, color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              blocks.push(
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'paragraph',
                  paragraph: {
                    rich_text: [
                      { text: { content: 'ğŸ¤– ì´ ë¦¬í¬íŠ¸ëŠ” GitHub Actionsì— ì˜í•´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.' }, annotations: { italic: true, color: 'gray' } }
                    ]
                  }
                }
              );
              
              console.log('ğŸ“¤ Creating Notion page...');
              const page = await createNotionPage();
              const pageId = page.id;

              console.log('ğŸ“ Total blocks to add:', blocks.length);

              // Notion has a limit of ~2000 blocks per page
              const MAX_BLOCKS = 1900;
              if (blocks.length > MAX_BLOCKS) {
                console.log('âš ï¸ Warning: Block count (' + blocks.length + ') exceeds recommended limit (' + MAX_BLOCKS + ')');
                console.log('âš ï¸ Truncating to ' + MAX_BLOCKS + ' blocks to prevent errors');
                blocks.splice(MAX_BLOCKS);
                blocks.push({
                  object: 'block',
                  type: 'callout',
                  callout: {
                    rich_text: [{
                      text: {
                        content: 'âš ï¸ ì¼ë¶€ í•­ëª©ì´ ìƒëµë˜ì—ˆìŠµë‹ˆë‹¤. ì „ì²´ ë‚´ìš©ì€ GitHubì—ì„œ í™•ì¸í•˜ì„¸ìš”.'
                      }
                    }],
                    icon: { emoji: 'âš ï¸' },
                    color: 'yellow_background'
                  }
                });
              }

              // Notion API allows max 100 blocks per request
              for (let i = 0; i < blocks.length; i += 100) {
                const chunk = blocks.slice(i, i + 100);
                console.log('ğŸ“¤ Adding blocks ' + (i + 1) + '-' + (i + chunk.length) + '...');
                await appendBlocksToNotion(pageId, chunk);
              }
              
              console.log('âœ… Daily report added to Notion');
              console.log('âœ… Daily report generation completed');

              console.log('ğŸ“¨ Sending Slack notification...');
              try {
                const notionPageUrl = page.url;

                const slackMessage = {
                  text: 'ì¼ê°„ ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ',
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'ğŸ“Š ì¼ê°„ ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: '*ë‚ ì§œ*\n' + dateStr + ' ' + periodStr
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ìƒì„± ì‹œê°„*\n' + new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' })
                        }
                      ]
                    },
                    {
                      type: 'section',
                      fields: [
                        {
                          type: 'mrkdwn',
                          text: '*ìƒˆ ì´ìŠˆ*\n' + newIssues.length + 'ê°œ'
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ì™„ë£Œ ì´ìŠˆ*\n' + closedIssues.length + 'ê°œ'
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ìƒˆ PR*\n' + newPRs.length + 'ê°œ'
                        },
                        {
                          type: 'mrkdwn',
                          text: '*ë¨¸ì§€ PR*\n' + mergedPRs.length + 'ê°œ'
                        }
                      ]
                    },
                    {
                      type: 'divider'
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: 'ğŸ“„ *ìƒì„¸ ë³´ê³ ì„œ*\nNotionì—ì„œ í™•ì¸í•˜ì„¸ìš”'
                      }
                    },
                    {
                      type: 'actions',
                      elements: [
                        {
                          type: 'button',
                          text: {
                            type: 'plain_text',
                            text: 'Notionì—ì„œ ë³´ê¸°',
                            emoji: true
                          },
                          url: notionPageUrl,
                          style: 'primary'
                        }
                      ]
                    }
                  ]
                };

                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
              } catch (slackError) {
                console.error('âš ï¸ Failed to send Slack notification:', slackError.message);
              }

            } catch (error) {
              console.error('âŒ Error:', error);

              try {
                const errorMessage = {
                  text: 'ì¼ê°„ ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨',
                  blocks: [
                    {
                      type: 'header',
                      text: {
                        type: 'plain_text',
                        text: 'âŒ ì¼ê°„ ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨',
                        emoji: true
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: '*ë‚ ì§œ*\n' + dateStr
                      }
                    },
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: '*ì˜¤ë¥˜ ë©”ì‹œì§€*\n```' + error.message + '```'
                      }
                    }
                  ]
                };

                await sendToSlack(errorMessage);
              } catch (slackError) {
                console.error('âš ï¸ Failed to send error notification to Slack:', slackError.message);
              }

              throw error;
            }
