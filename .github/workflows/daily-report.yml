name: Daily Report

on:
  schedule:
    - cron: '0 9 * * 1-5'
  workflow_dispatch:

permissions:
  contents: read
  issues: read
  pull-requests: read

jobs:
  generate-daily-report:
    runs-on: ubuntu-latest
    steps:
      - name: Generate Daily Report
        uses: actions/github-script@v7
        env:
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_REPORT_PAGE_ID: ${{ secrets.NOTION_REPORT_PAGE_ID }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const https = require('https');
            
            const now = new Date();
            const kstOffset = 9 * 60 * 60 * 1000;
            const kstDate = new Date(now.getTime() + kstOffset);
            const today = kstDate.toISOString().split('T')[0];
            const yesterday = new Date(kstDate.getTime() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            
            const dateStr = kstDate.toLocaleDateString('ko-KR', { 
              year: 'numeric', 
              month: 'long', 
              day: 'numeric',
              weekday: 'long'
            });
            
            const userNames = {
              'leemjmorris': 'ì´ëª…ì§„',
              'jaemoon23': 'ê¹€ì¬ë¬¸',
              'LeeChaeBin002': 'ì´ì±„ë¹ˆ',
              'Kdwio': 'ê¹€ë™ìš±',
              'bigwaterplz': 'ê¹€ë¯¼íœ˜',
              'kimjiw8698-crypto': 'ê¹€ì§€ì›'
            };
            
            async function generateGeminiSummary(issues, prs) {
              const geminiApiKey = process.env.GEMINI_API_KEY;
              
              const issuesList = issues.map(issue => {
                const assignees = issue.assignees.map(a => userNames[a.login] || a.login).join(', ') || 'ë¯¸ë°°ì •';
                const labels = issue.labels.map(l => l.name).join(', ');
                return '- #' + issue.number + ' ' + issue.title + ' (ë‹´ë‹¹: ' + assignees + ') [' + labels + '] - ' + issue.state;
              }).join('\n');
              
              const prsList = prs.map(pr => {
                const author = userNames[pr.user.login] || pr.user.login;
                return '- #' + pr.number + ' ' + pr.title + ' (ì‘ì„±: ' + author + ') - ' + (pr.merged_at ? 'ë¨¸ì§€ë¨' : pr.state);
              }).join('\n');
              
              const prompt = 'ë‹¹ì‹ ì€ Unity ê²Œì„ ê°œë°œ íŒ€ì˜ ì¼ì¼ ë³´ê³ ì„œë¥¼ ì‘ì„±í•˜ëŠ” AIì…ë‹ˆë‹¤.\n' +
                'ì•„ë˜ì˜ GitHub Issuesì™€ Pull Requestsë¥¼ ë¶„ì„í•˜ì—¬, íŒ€ì›ë³„ ì‘ì—… ë‚´ìš©ì„ ìš”ì•½í•´ì£¼ì„¸ìš”.\n\n' +
                '**íŒ€ì› ëª©ë¡:**\n' +
                '- ì´ëª…ì§„ (íŒ€ì¥, í”„ë¡œê·¸ë˜ë¨¸)\n' +
                '- ê¹€ì¬ë¬¸ (í”„ë¡œê·¸ë˜ë¨¸)\n' +
                '- ì´ì±„ë¹ˆ (í”„ë¡œê·¸ë˜ë¨¸/ë””ìì´ë„ˆ)\n' +
                '- ê¹€ë™ìš± (ë””ìì´ë„ˆ)\n' +
                '- ê¹€ë¯¼íœ˜ (ë””ìì´ë„ˆ)\n' +
                '- ê¹€ì§€ì› (ê¸°íšì)\n\n' +
                '**GitHub Issues (ìµœê·¼ 24ì‹œê°„):**\n' +
                (issuesList || 'ì—†ìŒ') + '\n\n' +
                '**Pull Requests (ìµœê·¼ 24ì‹œê°„):**\n' +
                (prsList || 'ì—†ìŒ') + '\n\n' +
                '**ìš”êµ¬ ì‚¬í•­:**\n' +
                '1. ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ìš”ì•½í•´ì£¼ì„¸ìš”:\n\n' +
                '# ì´ìŠˆ\n' +
                '- (ì™„ë£Œ ë˜ëŠ” ì§„í–‰ì¤‘) ë‹´ë‹¹ì - ì‘ì—… ë‚´ìš© ìš”ì•½\n\n' +
                '---\n\n' +
                '# ì „ì¼ ë³´ê³ \n' +
                '## ì™„ë£Œ\n' +
                '- ë‹´ë‹¹ì - ì™„ë£Œí•œ ì‘ì—… ë‚´ìš©\n\n' +
                '## ë¯¸ì™„ë£Œ (ì‚¬ìœ , ì²˜ë¦¬)\n' +
                '- ë‹´ë‹¹ì - ë¯¸ì™„ë£Œ ì‘ì—… ë° ì‚¬ìœ \n\n' +
                '---\n\n' +
                '# ê¸ˆì¼ ë³´ê³ \n' +
                '## ì˜¤ì „\n' +
                '- ë‹´ë‹¹ì - ì˜¤ì „ ì‘ì—… ê³„íš\n\n' +
                '## ì˜¤í›„\n' +
                '- ë‹´ë‹¹ì - ì˜¤í›„ ì‘ì—… ê³„íš\n\n' +
                '## (ì•¼ê·¼)\n' +
                '- ë‹´ë‹¹ì - ì•¼ê·¼ ì‘ì—… ê³„íš (ìˆëŠ” ê²½ìš°ì—ë§Œ)\n\n' +
                '2. Issueì˜ labelì„ ì°¸ê³ í•˜ì—¬ ì‘ì—…ì˜ ìš°ì„ ìˆœìœ„ì™€ ì¤‘ìš”ë„ë¥¼ íŒë‹¨í•˜ì„¸ìš”.\n' +
                '3. Issueì˜ ìƒíƒœ(open/closed)ë¥¼ ì°¸ê³ í•˜ì—¬ ì™„ë£Œ ì—¬ë¶€ë¥¼ íŒë‹¨í•˜ì„¸ìš”.\n' +
                '4. PRì˜ merge ì—¬ë¶€ë¥¼ ì°¸ê³ í•˜ì—¬ ì‘ì—… ì™„ë£Œë¥¼ íŒë‹¨í•˜ì„¸ìš”.\n' +
                '5. ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ ì‘ì„±í•˜ì„¸ìš”.\n' +
                '6. ì‘ì—… ë‚´ìš©ì´ ì—†ìœ¼ë©´ í•´ë‹¹ ì„¹ì…˜ì„ ìƒëµí•˜ì„¸ìš”.\n' +
                '7. ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ë˜, ì½”ë“œ ë¸”ë¡ì€ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”.\n\n' +
                'ìš”ì•½ì„ ì‹œì‘í•˜ì„¸ìš”:';

              return new Promise((resolve, reject) => {
                const postData = JSON.stringify({
                  contents: [{
                    parts: [{ text: prompt }]
                  }]
                });
                
                const req = https.request({
                  hostname: 'generativelanguage.googleapis.com',
                  path: '/v1beta/models/gemini-1.5-flash:generateContent?key=' + geminiApiKey,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(postData)
                  }
                }, (res) => {
                  console.log('ğŸ” Gemini API Status:', res.statusCode);
                  
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (result.candidates && result.candidates[0] && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0] && result.candidates[0].content.parts[0].text) {
                        console.log('âœ… AI summary generated successfully');
                        resolve(result.candidates[0].content.parts[0].text);
                      } else if (result.error) {
                        console.error('âŒ Gemini API Error:', result.error);
                        reject(new Error('Gemini API error: ' + result.error.message));
                      } else {
                        console.error('âŒ Unexpected response structure:', JSON.stringify(result));
                        reject(new Error('Invalid Gemini API response structure'));
                      }
                    } catch (e) {
                      console.error('âŒ Failed to parse Gemini response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('âŒ Gemini request error:', e);
                  reject(e);
                });
                
                req.write(postData);
                req.end();
              });
            }
            
            async function addToNotion(content) {
              const token = process.env.NOTION_API_TOKEN;
              const parentPageId = process.env.NOTION_REPORT_PAGE_ID;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  parent: { page_id: parentPageId },
                  icon: { emoji: 'ğŸ“Š' },
                  properties: {
                    title: {
                      title: [{ text: { content: dateStr + ' ê°œë°œ í˜„í™©' } }]
                    }
                  },
                  children: content
                });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const result = JSON.parse(body);
                      
                      if (res.statusCode === 200) {
                        console.log('ğŸ“„ Page URL:', result.url);
                        resolve(result);
                      } else {
                        console.error('âŒ Notion API Error:', JSON.stringify(result, null, 2));
                        reject(new Error('Notion API returned ' + res.statusCode + ': ' + (result.message || 'Unknown error')));
                      }
                    } catch (e) {
                      console.error('âŒ Failed to parse response:', body);
                      reject(e);
                    }
                  });
                });
                
                req.on('error', (e) => {
                  console.error('âŒ Request error:', e);
                  reject(e);
                });
                
                req.write(data);
                req.end();
              });
            }
            
            try {
              console.log('Generating daily report for ' + dateStr + '...');
              
              const issuesCreated = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                since: yesterday,
                state: 'all',
                per_page: 100
              });
              
              const newIssues = issuesCreated.data.filter(issue => 
                !issue.pull_request && 
                new Date(issue.created_at) >= new Date(yesterday)
              );
              
              const closedIssues = issuesCreated.data.filter(issue => 
                !issue.pull_request && 
                issue.state === 'closed' &&
                issue.closed_at &&
                new Date(issue.closed_at) >= new Date(yesterday)
              );
              
              const allRecentIssues = issuesCreated.data.filter(issue => !issue.pull_request);
              
              const prsCreated = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                sort: 'created',
                direction: 'desc',
                per_page: 100
              });
              
              const newPRs = prsCreated.data.filter(pr => 
                new Date(pr.created_at) >= new Date(yesterday)
              );
              
              const mergedPRs = prsCreated.data.filter(pr => 
                pr.merged_at &&
                new Date(pr.merged_at) >= new Date(yesterday)
              );
              
              const activeIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });
              
              const inProgressIssues = activeIssues.data.filter(issue => 
                !issue.pull_request &&
                issue.assignees.length > 0
              );
              
              console.log('ğŸ¤– Generating AI summary with Gemini...');
              const aiSummary = await generateGeminiSummary(allRecentIssues, prsCreated.data);
              console.log('âœ… AI summary generated');
              
              const userStats = {};
              
              for (const issue of inProgressIssues) {
                for (const assignee of issue.assignees) {
                  const userName = userNames[assignee.login] || assignee.login;
                  if (!userStats[userName]) {
                    userStats[userName] = {
                      inProgress: 0,
                      completed: 0,
                      prs: 0
                    };
                  }
                  userStats[userName].inProgress++;
                }
              }
              
              for (const issue of closedIssues) {
                for (const assignee of issue.assignees) {
                  const userName = userNames[assignee.login] || assignee.login;
                  if (!userStats[userName]) {
                    userStats[userName] = {
                      inProgress: 0,
                      completed: 0,
                      prs: 0
                    };
                  }
                  userStats[userName].completed++;
                }
              }
              
              for (const pr of mergedPRs) {
                const userName = userNames[pr.user.login] || pr.user.login;
                if (!userStats[userName]) {
                  userStats[userName] = {
                    inProgress: 0,
                    completed: 0,
                    prs: 0
                  };
                }
                userStats[userName].prs++;
              }
              
              const blocks = [];
              
              blocks.push({
                object: 'block',
                type: 'heading_2',
                heading_2: {
                  rich_text: [{ text: { content: 'ğŸ¤– AI ìš”ì•½' } }]
                }
              });
              
              const summaryLines = aiSummary.split('\n');
              for (const line of summaryLines) {
                if (line.trim()) {
                  blocks.push({
                    object: 'block',
                    type: 'paragraph',
                    paragraph: {
                      rich_text: [{ text: { content: line } }]
                    }
                  });
                }
              }
              
              blocks.push(
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'heading_2',
                  heading_2: {
                    rich_text: [{ text: { content: 'ğŸ“Š ì¼ì¼ ê°œë°œ í˜„í™©' } }]
                  }
                },
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'heading_3',
                  heading_3: {
                    rich_text: [{ text: { content: 'ğŸ“ˆ í†µê³„ ìš”ì•½' } }]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ìƒì„±ëœ Issue: ' } },
                      { text: { content: newIssues.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ì™„ë£Œëœ Issue: ' } },
                      { text: { content: closedIssues.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ìƒì„±ëœ PR: ' } },
                      { text: { content: newPRs.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ë¨¸ì§€ëœ PR: ' } },
                      { text: { content: mergedPRs.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                },
                {
                  object: 'block',
                  type: 'bulleted_list_item',
                  bulleted_list_item: {
                    rich_text: [
                      { text: { content: 'ì§„í–‰ ì¤‘ì¸ Issue: ' } },
                      { text: { content: inProgressIssues.length + 'ê°œ' }, annotations: { bold: true } }
                    ]
                  }
                }
              );
              
              if (Object.keys(userStats).length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ‘¥ íŒ€ì›ë³„ í˜„í™©' } }]
                    }
                  }
                );
                
                for (const [userName, stats] of Object.entries(userStats)) {
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { text: { content: userName + ': ' }, annotations: { bold: true } },
                        { text: { content: 'ì§„í–‰ì¤‘ ' + stats.inProgress + 'ê°œ ' } },
                        { text: { content: '/ ' }, annotations: { color: 'gray' } },
                        { text: { content: 'ì™„ë£Œ ' + stats.completed + 'ê°œ ' } },
                        { text: { content: '/ ' }, annotations: { color: 'gray' } },
                        { text: { content: 'PR ' + stats.prs + 'ê°œ' } }
                      ]
                    }
                  });
                }
              }
              
              if (newIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ†• ìƒì„±ëœ Issue' } }]
                    }
                  }
                );
                
                for (const issue of newIssues) {
                  const assigneeNames = issue.assignees.map(a => 
                    userNames[a.login] || a.login
                  ).join(', ') || 'ë¯¸ë°°ì •';
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: issue.title + ' ' } },
                        { text: { content: '(ë‹´ë‹¹: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              if (closedIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'âœ… ì™„ë£Œëœ Issue' } }]
                    }
                  }
                );
                
                for (const issue of closedIssues) {
                  const assigneeNames = issue.assignees.map(a => 
                    userNames[a.login] || a.login
                  ).join(', ') || 'ë¯¸ë°°ì •';
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true, strikethrough: true }
                        },
                        { text: { content: issue.title + ' ' }, annotations: { strikethrough: true } },
                        { text: { content: '(ë‹´ë‹¹: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              if (mergedPRs.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ”€ ë¨¸ì§€ëœ PR' } }]
                    }
                  }
                );
                
                for (const pr of mergedPRs) {
                  const authorName = userNames[pr.user.login] || pr.user.login;
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + pr.number + ' ',
                            link: { url: pr.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: pr.title + ' ' } },
                        { text: { content: '(ì‘ì„±ì: ' + authorName + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              if (inProgressIssues.length > 0) {
                blocks.push(
                  {
                    object: 'block',
                    type: 'divider',
                    divider: {}
                  },
                  {
                    object: 'block',
                    type: 'heading_3',
                    heading_3: {
                      rich_text: [{ text: { content: 'ğŸ”„ ì§„í–‰ ì¤‘ì¸ Issue' } }]
                    }
                  }
                );
                
                for (const issue of inProgressIssues.slice(0, 20)) {
                  const assigneeNames = issue.assignees.map(a => 
                    userNames[a.login] || a.login
                  ).join(', ');
                  
                  blocks.push({
                    object: 'block',
                    type: 'bulleted_list_item',
                    bulleted_list_item: {
                      rich_text: [
                        { 
                          text: { 
                            content: '#' + issue.number + ' ',
                            link: { url: issue.html_url }
                          },
                          annotations: { bold: true }
                        },
                        { text: { content: issue.title + ' ' } },
                        { text: { content: '(ë‹´ë‹¹: ' + assigneeNames + ')' }, annotations: { color: 'gray' } }
                      ]
                    }
                  });
                }
                
                if (inProgressIssues.length > 20) {
                  blocks.push({
                    object: 'block',
                    type: 'paragraph',
                    paragraph: {
                      rich_text: [
                        { text: { content: '... ì™¸ ' + (inProgressIssues.length - 20) + 'ê°œ' }, annotations: { italic: true, color: 'gray' } }
                      ]
                    }
                  });
                }
              }
              
              blocks.push(
                {
                  object: 'block',
                  type: 'divider',
                  divider: {}
                },
                {
                  object: 'block',
                  type: 'paragraph',
                  paragraph: {
                    rich_text: [
                      { text: { content: 'ğŸ¤– ì´ ë¦¬í¬íŠ¸ëŠ” GitHub Actionsì— ì˜í•´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.' }, annotations: { italic: true, color: 'gray' } }
                    ]
                  }
                }
              );
              
              console.log('ğŸ“¤ Sending to Notion...');
              const result = await addToNotion(blocks);
              console.log('âœ… Daily report added to Notion');
              
              console.log('âœ… Daily report generation completed');
              
            } catch (error) {
              console.error('âŒ Error:', error);
              core.setFailed(error.message);
            }
