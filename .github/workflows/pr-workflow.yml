name: PR Workflow

on:
  pull_request:
    types: [opened, review_requested, closed]

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  handle-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts/user-mapping.json
          sparse-checkout-cone-mode: false

      - name: Handle PR Event
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          script: |
            const fs = require('fs');
            const https = require('https');

            const prNumber = context.payload.pull_request.number;
            const prTitle = context.payload.pull_request.title;
            const prUrl = context.payload.pull_request.html_url;
            const action = context.payload.action;
            const author = context.payload.pull_request.user.login;
            const headBranch = context.payload.pull_request.head.ref;
            const baseBranch = context.payload.pull_request.base.ref;

            // Load user mapping from JSON file
            const userMappingData = JSON.parse(fs.readFileSync('.github/scripts/user-mapping.json', 'utf8'));
            const userMapping = {};
            for (const [username, data] of Object.entries(userMappingData)) {
              userMapping[username] = data.slackId;
            }
            
            function sendToSlack(message) {
              return new Promise((resolve, reject) => {
                if (!process.env.SLACK_WEBHOOK_URL) {
                  console.log('âš ï¸ SLACK_WEBHOOK_URL not set, skipping Slack notification');
                  resolve('skipped');
                  return;
                }

                const data = JSON.stringify(message);
                const url = new URL(process.env.SLACK_WEBHOOK_URL);

                const options = {
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(data)
                  }
                };

                const req = https.request(options, (res) => {
                  let body = '';
                  res.on('data', (chunk) => body += chunk);
                  res.on('end', () => {
                    if (res.statusCode === 200 && body === 'ok') {
                      resolve(body);
                    } else {
                      reject(new Error('Slack API error: ' + res.statusCode));
                    }
                  });
                });

                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            try {
              if (action === 'opened') {
                const slackUserId = userMapping[author];
                const mentionText = slackUserId ? `<@${slackUserId}>` : author;
                
                const slackMessage = {
                  text: 'ìƒˆë¡œìš´ PRì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤',
                  blocks: [
                    {
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `:rocket: *ìƒˆë¡œìš´ PR* #${prNumber}\n*ì œëª©:* ${prTitle}\n*ì‘ì„±ì:* ${mentionText}\n*Branch:* ${headBranch} â†’ ${baseBranch}\n<${prUrl}|PR ë³´ê¸°>`
                      }
                    }
                  ]
                };
                
                await sendToSlack(slackMessage);
              }
              
              if (action === 'review_requested') {
                const reviewers = context.payload.pull_request.requested_reviewers || [];
                const reviewerMentions = reviewers
                  .map(r => {
                    const slackUserId = userMapping[r.login];
                    return slackUserId ? `<@${slackUserId}>` : r.login;
                  })
                  .join(', ');

                if (reviewerMentions) {
                  const slackMessage = {
                    text: 'PR ë¦¬ë·°ê°€ ìš”ì²­ë˜ì—ˆìŠµë‹ˆë‹¤',
                    blocks: [
                      {
                        type: 'section',
                        text: {
                          type: 'mrkdwn',
                          text: `:eyes: *ë¦¬ë·° ìš”ì²­*\n${reviewerMentions}\n*PR:* #${prNumber} ${prTitle}\n*ì‘ì„±ì:* ${author}\n<${prUrl}|PR ë³´ê¸°>`
                        }
                      }
                    ]
                  };

                  await sendToSlack(slackMessage);
                }
              }

              if (action === 'closed') {
                const merged = context.payload.pull_request.merged;
                const slackUserId = userMapping[author];
                const mentionText = slackUserId ? `<@${slackUserId}>` : author;

                if (merged) {
                  const mergedBy = context.payload.pull_request.merged_by?.login || author;
                  const mergedBySlackId = userMapping[mergedBy];
                  const mergedByMention = mergedBySlackId ? `<@${mergedBySlackId}>` : mergedBy;

                  let closedIssue = null;

                  const issueMatch = headBranch.match(/issue-(\d+)/i) || headBranch.match(/(\d+)-/);
                  if (issueMatch) {
                    const issueNumber = parseInt(issueMatch[1]);
                    console.log(`ğŸ“Œ Found issue number in branch: ${issueNumber}`);

                    try {
                      const { data: issue } = await github.rest.issues.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber
                      });

                      if (issue.state === 'open') {
                        await github.rest.issues.update({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          state: 'closed',
                          state_reason: 'completed'
                        });

                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issueNumber,
                          body: `âœ… Automatically closed by merging PR #${prNumber}`
                        });

                        closedIssue = {
                          number: issueNumber,
                          title: issue.title,
                          url: issue.html_url
                        };

                        console.log(`âœ… Automatically closed issue #${issueNumber}`);
                      } else {
                        console.log(`â„¹ï¸ Issue #${issueNumber} is already ${issue.state}`);
                      }
                    } catch (error) {
                      console.error(`âš ï¸ Failed to close issue #${issueNumber}:`, error.message);
                    }
                  } else {
                    console.log('â„¹ï¸ No issue number found in branch name');
                  }

                  const slackMessage = {
                    text: 'PRì´ ë¨¸ì§€ë˜ì—ˆìŠµë‹ˆë‹¤',
                    blocks: [
                      {
                        type: 'header',
                        text: {
                          type: 'plain_text',
                          text: 'âœ… PR Merged',
                          emoji: true
                        }
                      },
                      {
                        type: 'section',
                        fields: [
                          {
                            type: 'mrkdwn',
                            text: `*PR #${prNumber}*\n${prTitle}`
                          },
                          {
                            type: 'mrkdwn',
                            text: `*Branch*\n${headBranch} â†’ ${baseBranch}`
                          }
                        ]
                      },
                      {
                        type: 'section',
                        fields: [
                          {
                            type: 'mrkdwn',
                            text: `*ì‘ì„±ì*\n${mentionText}`
                          },
                          {
                            type: 'mrkdwn',
                            text: `*ë¨¸ì§€í•œ ì‚¬ëŒ*\n${mergedByMention}`
                          }
                        ]
                      }
                    ]
                  };

                  if (closedIssue) {
                    slackMessage.blocks.push({
                      type: 'section',
                      text: {
                        type: 'mrkdwn',
                        text: `ğŸ¯ *ìë™ìœ¼ë¡œ ë‹«íŒ Issue*\n<${closedIssue.url}|#${closedIssue.number} ${closedIssue.title}>`
                      }
                    });
                  }

                  slackMessage.blocks.push({
                    type: 'actions',
                    elements: [
                      {
                        type: 'button',
                        text: {
                          type: 'plain_text',
                          text: 'View PR',
                          emoji: true
                        },
                        url: prUrl,
                        style: 'primary'
                      }
                    ]
                  });

                  await sendToSlack(slackMessage);
                } else {
                  const slackMessage = {
                    text: 'PRì´ ë‹«í˜”ìŠµë‹ˆë‹¤',
                    blocks: [
                      {
                        type: 'section',
                        text: {
                          type: 'mrkdwn',
                          text: `:x: *PR ë‹«í˜* #${prNumber}\n*ì œëª©:* ${prTitle}\n*ì‘ì„±ì:* ${mentionText}\n*Branch:* ${headBranch} â†’ ${baseBranch}\n<${prUrl}|PR ë³´ê¸°>`
                        }
                      }
                    ]
                  };

                  await sendToSlack(slackMessage);
                }
              }
              
            } catch (error) {
              console.error('Error:', error);
              throw error;
            }
