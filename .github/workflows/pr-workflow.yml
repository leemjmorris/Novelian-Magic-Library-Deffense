name: PR Workflow

on:
  pull_request:
    types: [opened, review_requested, closed]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  handle-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Handle PR Event
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          NOTION_API_TOKEN: ${{ secrets.NOTION_API_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        with:
          script: |
            const https = require('https');
            
            // LMJ : Get PR info (different structure for review events)
            const isPRReview = context.eventName === 'pull_request_review';
            const prNumber = context.payload.pull_request.number;
            const prTitle = context.payload.pull_request.title;
            const prUrl = context.payload.pull_request.html_url;
            const prBody = context.payload.pull_request.body || '';
            const action = context.payload.action;
            const author = context.payload.pull_request.user.login;
            const baseBranch = context.payload.pull_request.base.ref;
            const headBranch = context.payload.pull_request.head.ref;
            const state = context.payload.pull_request.state;
            const merged = context.payload.pull_request.merged;
            
            // LMJ : GitHub username to Slack User ID mapping
            const userMapping = {
              'leemjmorris': 'U09R6F3CBHN',
              'jaemoon23': 'U09QR380TLH',
              'LeeChaeBin002': 'U09QFND0J20',
              'Kdwio': 'U09LZ9Q6F3J',
              'bigwaterplz': 'U09PKGUMVA6',
              'kimjiw8698-crypto': 'U09QDRGNT08'
            };
            
            // LMJ : Convert author to Slack mention
            const authorMention = userMapping[author] ? `<@${userMapping[author]}>` : `@${author}`;
            
            async function sendToSlack(message) {
              const webhookUrl = process.env.SLACK_WEBHOOK_URL;
              const url = new URL(webhookUrl);
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({ text: message });
                const req = https.request({
                  hostname: url.hostname,
                  path: url.pathname + url.search,
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => resolve(body));
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            async function addToNotion(title, prUrl, status) {
              const token = process.env.NOTION_API_TOKEN;
              const databaseId = process.env.NOTION_DATABASE_ID;
              
              return new Promise((resolve, reject) => {
                const data = JSON.stringify({
                  parent: { database_id: databaseId },
                  properties: {
                    "ì œëª©": {
                      title: [{ text: { content: title } }]
                    },
                    "íƒ€ì…": {
                      select: { name: "PR" }
                    },
                    "ìƒíƒœ": {
                      select: { name: status }
                    },
                    "GitHub URL": {
                      url: prUrl
                    }
                  }
                });
                
                const req = https.request({
                  hostname: 'api.notion.com',
                  path: '/v1/pages',
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => resolve(JSON.parse(body)));
                });
                req.on('error', reject);
                req.write(data);
                req.end();
              });
            }
            
            async function updateNotionStatus(prUrl, status) {
              const token = process.env.NOTION_API_TOKEN;
              const databaseId = process.env.NOTION_DATABASE_ID;
              
              // LMJ : Search for page with matching URL
              return new Promise((resolve, reject) => {
                const searchData = JSON.stringify({
                  filter: {
                    property: "GitHub URL",
                    url: { equals: prUrl }
                  }
                });
                
                const searchReq = https.request({
                  hostname: 'api.notion.com',
                  path: `/v1/databases/${databaseId}/query`,
                  method: 'POST',
                  headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Notion-Version': '2022-06-28'
                  }
                }, (res) => {
                  let body = '';
                  res.on('data', d => body += d);
                  res.on('end', () => {
                    try {
                      const searchResult = JSON.parse(body);
                      if (searchResult.results && searchResult.results.length > 0) {
                        const pageId = searchResult.results[0].id;
                        
                        // LMJ : Update status
                        const updateData = JSON.stringify({
                          properties: {
                            "ìƒíƒœ": {
                              select: { name: status }
                            }
                          }
                        });
                        
                        const updateReq = https.request({
                          hostname: 'api.notion.com',
                          path: `/v1/pages/${pageId}`,
                          method: 'PATCH',
                          headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json',
                            'Notion-Version': '2022-06-28'
                          }
                        }, (updateRes) => {
                          let updateBody = '';
                          updateRes.on('data', d => updateBody += d);
                          updateRes.on('end', () => resolve(JSON.parse(updateBody)));
                        });
                        updateReq.on('error', reject);
                        updateReq.write(updateData);
                        updateReq.end();
                      } else {
                        resolve({ error: 'Page not found' });
                      }
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                searchReq.on('error', reject);
                searchReq.write(searchData);
                searchReq.end();
              });
            }
            
            try {
              console.log(`Event: ${context.eventName}, Action: ${action}`);
              
              // ========================================
              // LMJ : Handle PULL_REQUEST_REVIEW submitted event
              // ========================================
              if (isPRReview && action === 'submitted') {
                console.log('ğŸ“ Review submitted');
                
                const review = context.payload.review;
                const reviewer = review.user.login;
                const reviewState = review.state;
                const reviewBody = review.body || '';
                
                const reviewerMention = userMapping[reviewer] ? `<@${userMapping[reviewer]}>` : `@${reviewer}`;
                
                let statusEmoji = 'ğŸ’¬';
                let statusText = 'ì½”ë©˜íŠ¸';
                let notionStatus = 'ë¦¬ë·° ì¤‘';
                
                if (reviewState === 'approved') {
                  statusEmoji = 'âœ…';
                  statusText = 'ìŠ¹ì¸';
                  notionStatus = 'ìŠ¹ì¸ë¨';
                } else if (reviewState === 'changes_requested') {
                  statusEmoji = 'ğŸ”„';
                  statusText = 'ìˆ˜ì • ìš”ì²­';
                  notionStatus = 'ìˆ˜ì • ìš”ì²­';
                }
                
                // LMJ : Send Slack notification
                const slackMessage = `${statusEmoji} *PR #${prNumber} ${statusText}*

*${prTitle}*

ğŸ‘¤ *ì‘ì„±ì:* ${authorMention}
ğŸ” *ë¦¬ë·°ì–´:* ${reviewerMention}
${reviewBody ? `\nğŸ’¬ *ì½”ë©˜íŠ¸:* ${reviewBody.substring(0, 100)}${reviewBody.length > 100 ? '...' : ''}` : ''}

ğŸ”— <${prUrl}|PR ë³´ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
                
                // LMJ : Update Notion status
                await updateNotionStatus(prUrl, notionStatus);
                console.log(`âœ… Notion status updated to ${notionStatus}`);
              }
              
              // ========================================
              // LMJ : Handle OPENED event
              // ========================================
              else if (action === 'opened') {
                console.log('ğŸ”€ PR opened');
                
                // LMJ : Extract linked issue numbers
                const issueNumbers = [];
                const issueRegex = /#(\d+)|close[sd]?\s+#(\d+)|fix(?:e[sd])?\s+#(\d+)|resolve[sd]?\s+#(\d+)/gi;
                let match;
                while ((match = issueRegex.exec(prBody)) !== null) {
                  const issueNum = match[1] || match[2] || match[3] || match[4];
                  if (issueNum && !issueNumbers.includes(issueNum)) {
                    issueNumbers.push(issueNum);
                  }
                }
                
                const linkedIssues = issueNumbers.length > 0 
                  ? issueNumbers.map(n => `#${n}`).join(', ')
                  : 'ì—†ìŒ';
                
                // LMJ : Send Slack notification
                const slackMessage = `ğŸ”€ *PR #${prNumber} ìƒì„±ë¨*

*${prTitle}*

ğŸ‘¤ *ì‘ì„±ì:* ${authorMention}
ğŸ”— *ì—°ê²°ëœ Issue:* ${linkedIssues}
ğŸŒ¿ *ë¸Œëœì¹˜:* \`${headBranch}\` â†’ \`${baseBranch}\`

ğŸ”— <${prUrl}|PR ë³´ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
                
                // LMJ : Add to Notion
                await addToNotion(prTitle, prUrl, 'ë¦¬ë·° ëŒ€ê¸°');
                console.log('âœ… Added to Notion');
                
                // LMJ : Check if Issue is linked
                if (issueNumbers.length === 0) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: 'âš ï¸ **ì´ PRì€ ì—°ê²°ëœ Issueê°€ ì—†ìŠµë‹ˆë‹¤.**\n\nPR ì„¤ëª…ì— `Closes #ì´ìŠˆë²ˆí˜¸` ë˜ëŠ” `Fixes #ì´ìŠˆë²ˆí˜¸`ë¥¼ ì¶”ê°€í•˜ì—¬ Issueì™€ ì—°ê²°í•˜ì„¸ìš”.'
                  });
                  console.log('âš ï¸ Warning comment added for missing issue link');
                }
              }
              
              // ========================================
              // LMJ : Handle REVIEW_REQUESTED event
              // ========================================
              else if (action === 'review_requested') {
                console.log('ğŸ‘€ Review requested');
                
                const reviewer = context.payload.requested_reviewer.login;
                const reviewerMention = userMapping[reviewer] ? `<@${userMapping[reviewer]}>` : `@${reviewer}`;
                
                // LMJ : Send Slack notification
                const slackMessage = `ğŸ‘€ *PR #${prNumber} ë¦¬ë·° ìš”ì²­*

*${prTitle}*

ğŸ‘¤ *ì‘ì„±ì:* ${authorMention}
ğŸ” *ë¦¬ë·°ì–´:* ${reviewerMention}

ğŸ”— <${prUrl}|PR ë¦¬ë·°í•˜ê¸°>`;
                
                await sendToSlack(slackMessage);
                console.log('âœ… Slack notification sent');
                
                // LMJ : Update Notion status
                await updateNotionStatus(prUrl, 'ë¦¬ë·° ì¤‘');
                console.log('âœ… Notion status updated');
              }
              
              // ========================================
              // LMJ : Handle CLOSED event (merged or closed without merge)
              // ========================================
              else if (action === 'closed') {
                if (merged) {
                  console.log('âœ… PR merged');
                  
                  // LMJ : Get merged by user
                  const mergedBy = context.payload.pull_request.merged_by?.login || 'unknown';
                  const mergedByMention = userMapping[mergedBy] ? `<@${userMapping[mergedBy]}>` : `@${mergedBy}`;
                  
                  // LMJ : Send Slack notification
                  const slackMessage = `âœ… *PR #${prNumber} ë¨¸ì§€ ì™„ë£Œ*

*${prTitle}*

ğŸ‘¤ *ì‘ì„±ì:* ${authorMention}
âœ… *ë¨¸ì§€í•œ ì‚¬ëŒ:* ${mergedByMention}
ğŸŒ¿ *ë¸Œëœì¹˜:* \`${headBranch}\` â†’ \`${baseBranch}\`

ğŸ”— <${prUrl}|PR ë³´ê¸°>`;
                  
                  await sendToSlack(slackMessage);
                  console.log('âœ… Slack notification sent');
                  
                  // LMJ : Update Notion status
                  await updateNotionStatus(prUrl, 'ì™„ë£Œ');
                  console.log('âœ… Notion status updated to ì™„ë£Œ');
                } else {
                  console.log('âŒ PR closed without merge');
                  
                  // LMJ : Send Slack notification
                  const slackMessage = `âŒ *PR #${prNumber} ë¨¸ì§€ ì—†ì´ ë‹«í˜*

*${prTitle}*

ğŸ‘¤ *ì‘ì„±ì:* ${authorMention}

ğŸ”— <${prUrl}|PR ë³´ê¸°>`;
                  
                  await sendToSlack(slackMessage);
                  console.log('âœ… Slack notification sent');
                  
                  // LMJ : Update Notion status
                  await updateNotionStatus(prUrl, 'ì·¨ì†Œë¨');
                  console.log('âœ… Notion status updated to ì·¨ì†Œë¨');
                }
              }
              
              console.log('âœ… Workflow completed successfully');
              
            } catch (error) {
              console.error('âŒ Error:', error);
              core.setFailed(error.message);
            }
